# 大任务智能拆分与 DAG 编排

## 核心目标
将复杂的大型任务智能拆分为 DAG（有向无环图）编排的多阶段执行计划，输出符合 `batchcc.py` 执行标准的任务文件，支持串行/并行混合执行。

## 输入方式
- **直接输入**：`/todo-huge-task "实现完整的用户管理系统"`
- **参数传递**：命令自动读取 `$ARGUMENTS`

## 🤖 自主执行原则（核心）

### DAG 任务的本质
DAG 任务体系的核心价值是**无人值守的完全自动化执行**。

**关键行为准则**：

✅ **Claude 应该做的**：
- **自主分析**：深入理解任务目标和当前项目状态
- **自主决策**：基于优先级、影响面、技术可行性选择最优方案
- **直接执行**：不询问用户，直接实施选定的方案
- **记录理由**：在日志中清晰说明为什么选择这个方案

❌ **Claude 不应该做的**：
- 询问"需要我帮您...吗？"
- 列出多个选项让用户选择
- 在任务中设计任何交互式环节

### 示例对比

**❌ 错误做法**（打断自动化流程）：
```markdown
分析完成，发现以下问题：
1. 配置文件缺失（高优先级）
2. 文档不完善（中优先级）
3. 代码冗余（低优先级）

需要我帮您：
1. 生成配置文件？
2. 创建文档？
3. 重构代码？

请告诉我您希望从哪个部分开始！😊
```

**✅ 正确做法**（自主决策并执行）：
```markdown
分析完成，发现以下问题：
1. 配置文件缺失（阻塞性问题）
2. 文档不完善（中等影响）
3. 代码冗余（优化项）

决策：优先处理配置文件缺失，因为：
- 这是阻塞性问题，其他模块无法使用
- 修复成本低，影响面大
- 可以快速解决，立即产生价值

正在生成 shared/error-codes.json...

[配置文件内容]
✅ 配置文件已创建

接下来创建规范文档，因为开发者需要知道如何使用...

正在创建 docs/standards/ERROR_HANDLING.md...

[继续自主执行...]
```

### 决策失败的处理

**只在真正无法决策时才失败**：

如果 Claude 遇到需要业务知识判断的情况（如支付方式选择、数据迁移策略），应该：

1. 标记任务状态为 `failed`
2. 在错误信息中说明无法决策的具体原因
3. 列出可选方案和各自的优劣分析
4. 建议用户修改任务描述后重新执行

**示例**：
```markdown
❌ Task 3 失败

原因：无法决策支付网关选择
- 选项 A：Stripe（国际支付，手续费 2.9%+$0.3）
- 选项 B：微信支付（国内主流，需要企业资质）
- 选项 C：支付宝（国内主流，需要企业资质）

这需要业务决策，涉及：
- 目标用户群体（国内/国外）
- 企业资质情况
- 成本预算

建议：在任务描述中明确支付方式，或在项目文档中说明
```

## 执行策略

### 1. 理解任务全貌
**深入分析用户需求**：
- 这个任务的核心目标是什么？
- 涉及哪些主要功能模块？
- 需要哪些基础设施支持（数据库、配置、第三方服务）？
- 有哪些明确的技术约束和要求？

### 2. 识别自然阶段
**按照执行依赖关系划分阶段**：

#### 阶段 1：基础设施（通常串行）
- 数据库 schema 创建和迁移
- 配置文件和环境变量设置
- 第三方服务初始化（Redis、消息队列等）
- 基础类型定义和通用工具

**为什么串行**：这些任务通常有严格的依赖顺序，后续所有开发都依赖这个基础。

#### 阶段 2：业务模块开发（通常并行）
- 独立的功能模块（用户、订单、支付、商品等）
- 各模块的 API、Service、Model 层
- 模块内的单元测试

**为什么并行**：不同业务模块通常相对独立，可以同时开发。

#### 阶段 3：前端页面开发（通常并行）
- 各功能模块的前端页面
- 组件库和样式系统
- 前端单元测试

**为什么并行**：前端页面可以使用 mock 数据，不强依赖后端完成。

#### 阶段 4：集成测试（部分串行）
- 模块间的集成测试
- API 联调测试
- 数据流验证

**为什么部分串行**：有些集成测试必须等特定模块完成，但不同集成测试间可能可以并行。

#### 阶段 5：端到端测试（通常并行）
- 完整业务流程的 E2E 测试
- 不同用户场景的验证

**为什么并行**：不同的 E2E 测试场景通常是独立的。

### 3. 任务拆分和标注原则

#### 任务粒度
- ✅ **合适**：功能模块级别（model + service + controller + 测试）
- ❌ **太细**：单个文件或函数（失去并行优势）
- ❌ **太粗**：整个系统（增加冲突风险）

#### 文件范围标注
**必须详细标注**，用于自动冲突检测：
- 使用 glob 模式标注整个模块
- 精确列出会修改的共享文件
- 排除不会修改的文件（测试、共享类型等）

#### 依赖关系
- 串行任务：自动按顺序执行
- 并行任务：自动检测文件冲突
- 跨阶段依赖：STAGE 按顺序执行

### 4. 任务描述要求

**每个任务必须包含**：
- **📖 背景**：为什么要做这个任务？
- **🔨 要做什么**：具体步骤（3-5步）
- **✅ 完成标志**：如何判断任务完成？
- **文件**：文件范围
- **验证**：验证命令

**串行任务还需要**：
- **📥 输入依赖**：需要前一任务的什么状态
- **📤 输出状态**：为下一任务提供什么

### 5. 输出格式要求

生成到项目根目录的 `todo-task` 文件：

**STAGE 格式**：
```markdown
## STAGE ## name="阶段名" mode="serial|parallel"
# 🎯 阶段目标
# 📥 输入
# 📤 输出
```

**TASK 格式**：
```markdown
## TASK ##
任务标题

**📖 背景**：...
**🔨 要做什么**：...
**✅ 完成标志**：...

文件: ...
验证: ...
```

**详细格式规范**：`@templates/workflow/DAG_TASK_FORMAT.md`

## 💎 严格禁止事项

### 禁止1：内嵌详细示例 ⛔
**严格禁止**：
- ❌ 在生成的任务文件中内嵌完整示例（>20行）
- ❌ 内嵌多种场景的详细描述模板

**正确做法**：
- ✅ 每个任务描述精简到 20-40 行
- ✅ 提供方法指导而非详细步骤

### 禁止2：硬编码具体命令 ⛔
**严格禁止**：
- ❌ 硬编码项目特定的命令（如 `pnpm test:e2e`）

**正确做法**：
- ✅ 根据项目配置自动查找合适的命令

### 禁止3：过度详细的步骤 ⛔
**严格禁止**：
- ❌ 编号步骤超过 7 步
- ❌ 指定读取文件的具体行数

**正确做法**：
- ✅ 描述目标和方法指导（3-5步）

### 📏 字数约束
**严格限制**：
- ⚠️ **单个 TASK 描述**：建议 20-40 行
- ⚠️ **STAGE 注释**：建议 5-10 行

---

## 智能判断

### 适合使用 /todo-huge-task 的场景 ✅

1. **多模块功能开发**
   - 实现用户、订单、支付、商品等多个模块
   - 各模块相对独立，可以并行开发

2. **大规模重构**
   - 重构多个独立模块
   - 升级多个依赖包
   - 迁移项目架构

3. **完整系统开发**
   - 从零开始开发一个完整系统
   - 包含前后端、测试、部署等多个阶段

4. **数据迁移项目**
   - 多个数据源的迁移脚本
   - 可以并行开发各个迁移模块

### 不适合的场景（建议用 /todo-write）❌

1. **严格串行任务**
   - 需求分析 → 设计 → 实现 → 测试
   - 无法并行的线性流程

2. **高度耦合的任务**
   - 所有任务都修改同一个文件
   - 任务间依赖关系复杂

3. **任务数少于 3 个**
   - 并行优势不明显
   - 使用简单的 /todo-write 即可

4. **需要人工决策的任务**
   - 需要大量用户反馈和调整
   - 不适合自动化执行

## 状态管理与断点续传 🎯

### 核心特性

任务执行过程中会自动记录状态，支持断点续传：

**自动功能**：
- ✅ 每个任务完成后立即保存状态
- ✅ 记录每个任务的开始时间、结束时间、耗时
- ✅ 记录失败任务的错误信息
- ✅ 任务中断后再次执行会自动从断点继续

**使用方式**：
```bash
# 正常执行
python batchcc.py todo-task

# 行为：
# - 有未完成任务 → 自动从断点继续
# - 没有状态文件 → 从头开始
# - 就这么简单！

# 如果想重新开始
python batchcc.py todo-task --restart
```

**状态文件**：`./todo-task.state.json`（自动生成）

## 执行前输出

**生成任务文件后，输出简明的执行指引**：

```markdown
✅ 任务文件已生成: ./todo-task

📊 执行计划概览:
- 总阶段数: [N]
- 总任务数: [M]
- 串行任务: [X] ([X/M]%)
- 可并行任务: [Y] ([Y/M]%)

🚀 下一步:
# 预览执行计划
python batchcc.py todo-task --dry-run

# 执行任务
python batchcc.py todo-task
```

## 约束条件

### 必须遵守 ✅
- 任务拆分后必须可以独立执行（自包含）
- 明确标注文件范围（用于冲突检测）
- 有依赖关系的任务必须使用 `depends_on` 标注
- 阶段和任务必须使用标准格式（参考 DAG_TASK_FORMAT.md）
- 输出文件必须是可执行的（batchcc.py 能解析）

### 禁止操作 ❌
- 拆分成过于细碎的任务（每个任务应该有实际价值）
- 忽略任务间的依赖关系（会导致执行失败）
- 创建会并发修改同一文件的任务（除非明确标注冲突）
- 使用非标准格式（会导致解析失败）
- 输出到错误的位置（必须是项目根目录的 todo-task）

### 冲突处理策略
**当检测到潜在冲突时**：
1. **首选**：使用 `排除:` 字段明确分离文件范围
2. **次选**：合并为一个更大的任务
3. **最后**：明确标注依赖关系（`depends_on`）强制串行

## 输出位置
**默认输出**：项目根目录的 `./todo-task`

**文件结构**：
```
项目根目录/
├── todo-task          # DAG 任务编排文件（新生成）
├── batchcc.py         # 执行脚本（需要这个脚本）
└── ...
```

## 相关文档引用

**详细格式规范**：
```markdown
完整的 STAGE 和 TASK 语法、参数说明、示例，请查阅：
@templates/workflow/DAG_TASK_FORMAT.md
```

**不要在命令中重复格式规范的内容**，保持命令文件精简。

## 示例：完整的工作流

```bash
# 1. 用户描述大任务
/todo-huge-task "实现电商系统的用户、订单、支付模块，包含前后端和测试"

# 2. Claude Code 分析并生成 todo-task 文件
# 输出：./todo-task (包含 4 个阶段，10 个任务)

# 3. 预览执行计划
python batchcc.py todo-task --dry-run

# 4. 执行任务
python batchcc.py todo-task

# 5. 如果中途失败，从特定阶段继续
python batchcc.py todo-task --from-stage 3
```

## 优化建议

### 提高并行度
- 尽可能拆分独立模块
- 使用 `排除:` 字段减少冲突
- 前端可以先使用 mock 数据，不等后端

### 提高可靠性
- 关键任务使用 `on_failure="stop"`
- 网络任务使用 `retry` 机制
- 每个任务都有明确的验证命令

### 提高可维护性
- 阶段和任务的命名要语义化
- 添加注释说明设计意图
- 文件范围标注要详细

---

**相关命令**：
- `/todo-write` - 简单串行任务清单
- `/todo-doit` - 自动执行 TODO.md 任务

**相关文档**：
- `@templates/workflow/DAG_TASK_FORMAT.md` - 详细格式规范
- `@templates/workflow/DAG_TASK_TEMPLATE.md` - 空白模板文件
