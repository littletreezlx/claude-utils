# 测试规划（Test Planning）

> **用途**：全面分析项目测试现状，生成可执行的测试任务
>
> **核心特性**：
> - ✅ DAG 任务编排（并行执行独立模块测试）
> - ✅ 自动断点续传（测试被中断可自动继续）
> - ✅ 状态管理（可视化进度和耗时）
> - ✅ 预览执行计划（`--dry-run`）
>
> **适用场景**：
> - 新项目测试搭建
> - 现有项目测试补充
> - 测试覆盖度提升
> - 测试缺口识别

---

## 🎯 工作原理

采用 **DAG 任务编排模式**：

```
/test-plan
    ↓
分析项目测试现状
    ↓
生成 task-add-test（DAG 格式）
    ↓
输出任务文件路径和执行命令
    ↓
    ↓
python batchcc.py task-add-test（执行）
    ↓
自动执行（支持中断和续传）：
  - STAGE 1（串行）: 测试基础设施准备
  - STAGE 2（并行）: 多模块测试编写
  - STAGE 3（串行）: 测试验证和覆盖度检查
    ↓
✅ 所有测试任务完成
```

---

## 🚀 使用方法

```bash
# 步骤1: 生成测试任务文件
/test-plan

# 步骤2: 预览执行计划
python batchcc.py task-add-test --dry-run

# 步骤3: 执行测试任务（自动断点续传）
git commit -am "Before adding tests"
python batchcc.py task-add-test

# 步骤4: 如果中断，直接再次运行（自动从断点继续）
python batchcc.py task-add-test

# 步骤5: 查看执行状态
cat task-add-test.state.json
```

---

## 📋 执行策略

### 核心目标

生成以下文件结构：

```
项目根目录/
├── task-add-test                      # 主任务文件（精简）
├── task-add-test.state.json           # 状态文件（自动生成）
│
└── .test-tasks/                       # 测试任务细节
    ├── stage-1-infrastructure.md      # 测试基础设施
    ├── stage-2-tests.md               # 测试编写任务
    └── stage-3-verification.md        # 测试验证
```

---

## 执行步骤

### 步骤1: 分析项目测试现状

**分析内容**：
- 扫描项目测试文件结构和覆盖范围
- 分析现有测试的类型分布（单元/集成/E2E）
- 评估测试质量和完整性
- 识别缺少测试的核心模块
- 检查测试基础设施（测试框架、配置、CI/CD）

**优先级判断维度**：
- **业务关键度**：核心业务逻辑 > 辅助功能 > 边缘特性
- **复杂度**：复杂算法 > 简单逻辑
- **变更频率**：频繁修改的模块优先
- **风险等级**：容易出错、影响面大的代码优先

**测试策略建议**：
- **纯函数/工具类**：单元测试
- **业务逻辑/服务层**：单元测试 + 集成测试
- **API端点**：集成测试
- **用户核心流程**：E2E测试

**输出**：
- 测试现状评估
- 测试缺口列表（按优先级）
- 测试策略建议

---

### 步骤2: 生成 task-add-test 主文件

**参考模板**：`@templates/workflow/DAG_TASK_FORMAT.md`

**任务文件结构**：

```markdown
# 测试任务规划 - [项目名]

## 项目背景
[简要说明项目测试现状和需要补充测试的原因]

## 测试目标
[列出测试的核心目标，如：覆盖核心业务逻辑、提高关键模块覆盖率等]

## STAGE ## name="infrastructure" mode="serial"
# 🎯 阶段目标：测试基础设施准备
# 📥 输入：当前项目代码和测试环境
# 📤 输出：测试环境就绪，可编写测试
# 🔗 为下一阶段提供：稳定的测试基础设施

@.test-tasks/stage-1-infrastructure.md

## STAGE ## name="tests" mode="parallel" max_workers="4"
# 🎯 阶段目标：并行编写多模块测试
# 📥 输入：测试环境就绪
# 📤 输出：各模块测试完成
# 🔗 为下一阶段提供：完整的测试套件

@.test-tasks/stage-2-tests.md

## STAGE ## name="verification" mode="serial"
# 🎯 阶段目标：测试验证和覆盖度检查
# 📥 输入：所有测试编写完成
# 📤 输出：测试通过，覆盖度达标

@.test-tasks/stage-3-verification.md
```

---

### 步骤3: 生成各阶段的详细任务文件

#### .test-tasks/stage-1-infrastructure.md

测试基础设施准备任务：

```markdown
## TASK ##
检查并配置测试框架

**📖 背景**：
确保项目有完整的测试基础设施

**🔨 要做什么**：
1. 检查测试框架配置（Jest/Vitest/Mocha等）
2. 检查测试覆盖率工具配置
3. 如有缺失，添加必要配置
4. 验证测试框架可正常运行

**✅ 完成标志**：
- 测试框架配置完整
- 测试命令可正常运行
- 覆盖率工具配置完成

**📤 输出状态**：
- ✅ 测试基础设施就绪

文件: jest.config.js, vitest.config.js, package.json
验证: npm test -- --version

## TASK ##
设置测试工具和辅助函数

**📖 背景**：
准备测试所需的工具和辅助函数

**🔨 要做什么**：
1. 检查测试工具库（testing-library, supertest等）
2. 创建测试辅助函数（如数据工厂、mock工具）
3. 配置测试环境变量
4. 准备测试数据库或mock服务

**✅ 完成标志**：
- 测试工具库安装完成
- 测试辅助函数可用
- 测试环境配置完成

**📥 输入依赖**：
- ⬆️ 测试框架配置完成

**📤 输出状态**：
- ✅ 测试工具就绪

文件: tests/helpers/*, tests/fixtures/*, .env.test
验证: [ -d tests/helpers ]
```

#### .test-tasks/stage-2-tests.md

并行编写测试任务：

```markdown
## TASK ##
[模块名1] - 单元测试

**📖 背景**：
[说明为什么需要这个模块的测试，模块的业务关键度或复杂度]

**🔨 要做什么**：
1. 编写核心函数的单元测试
2. 覆盖主要业务逻辑
3. 包含边界情况和错误处理

**✅ 完成标志**：
- 核心函数测试覆盖
- 测试通过
- 覆盖关键业务场景

**📥 输入依赖**：
- ⬆️ 测试基础设施就绪

**📤 输出状态**：
- ✅ [模块名1] 单元测试完成

文件: src/[模块1]/**/*.ts, tests/[模块1]/**/*.test.ts
排除: src/[其他模块]/**/*, tests/[其他模块]/**/*
验证: npm test -- --testPathPattern=[模块1]

## TASK ##
[模块名2] - 集成测试

**📖 背景**：
[说明为什么需要这个模块的集成测试]

**🔨 要做什么**：
1. 编写模块间交互测试
2. 测试 API 端点
3. 验证数据流正确性

**✅ 完成标志**：
- 模块集成测试覆盖
- 测试通过
- API 端点验证完成

**📥 输入依赖**：
- ⬆️ 测试基础设施就绪

**📤 输出状态**：
- ✅ [模块名2] 集成测试完成

文件: src/[模块2]/**/*.ts, tests/[模块2]/**/*.test.ts
排除: src/[其他模块]/**/*, tests/[其他模块]/**/*
验证: npm test -- --testPathPattern=[模块2]

## TASK ##
核心用户流程 - E2E测试

**📖 背景**：
验证用户核心功能流程端到端正常工作

**🔨 要做什么**：
1. 编写核心用户流程的 E2E 测试
2. 覆盖主要业务场景
3. 验证用户界面交互

**✅ 完成标志**：
- 核心流程 E2E 测试完成
- 测试通过
- 覆盖主要用户场景

**📥 输入依赖**：
- ⬆️ 测试基础设施就绪

**📤 输出状态**：
- ✅ E2E 测试完成

文件: tests/e2e/**/*.test.ts
验证: npm run test:e2e
```

#### .test-tasks/stage-3-verification.md

测试验证任务：

```markdown
## TASK ##
运行完整测试套件

**📖 背景**：
验证所有测试正常运行

**🔨 要做什么**：
1. 运行所有单元测试
2. 运行所有集成测试
3. 运行所有 E2E 测试
4. 生成测试覆盖率报告

**✅ 完成标志**：
- 所有测试通过
- 测试覆盖率报告生成

**📥 输入依赖**：
- ⬆️ 所有测试编写完成

**📤 输出状态**：
- ✅ 测试套件验证通过

文件: tests/**/*.test.ts
验证: npm test && npm run test:coverage

## TASK ##
更新测试文档

**📖 背景**：
更新项目文档反映新增测试

**🔨 要做什么**：
1. 更新 docs/testing/COVERAGE_MAP.md（如果维护）
2. 更新 README.md 的测试说明（如有必要）
3. 记录测试策略和覆盖范围

**✅ 完成标志**：
- 测试文档更新完成
- 覆盖度地图更新（如适用）

**📥 输入依赖**：
- ⬆️ 测试验证通过

**📤 输出状态**：
- ✅ 测试文档更新完成

文件: docs/testing/COVERAGE_MAP.md, README.md
验证: [ -f docs/testing/COVERAGE_MAP.md ] || echo "不维护覆盖度地图"
```

---

## 🎯 重要约束

### 1. 务实测试 ⚠️
- **必须测试**：核心业务逻辑、用户主要功能流程、容易破坏的关键模块
- **可选测试**：边界情况、性能测试、工具函数
- **不需要测试**：简单的 getter/setter、纯展示组件、一次性脚本
- **原则**：专注核心价值，避免过度测试

### 3. 并行优化 ⚠️
- 独立模块的测试可并行编写
- 依赖其他模块的测试需串行执行
- 明确文件范围，避免并发修改冲突

### 4. 测试质量 ⚠️
- 测试应该验证行为而非实现细节
- 避免脆弱的测试（过度依赖内部实现）
- 测试应该清晰、可维护

### 5. Git 里程碑 ⚠️
- 测试前确保 Git 工作区干净
- 建议在任务中添加提交点
- 方便回滚

---

## 💡 核心价值

**相比传统测试规划**：

| 传统流程 | DAG 模式 |
|---------|----------|
| ❌ 只生成规划文档 | ✅ 生成可执行任务 |
| ❌ 需要手动执行每个测试 | ✅ 自动执行所有任务 |
| ❌ 串行编写测试效率低 | ✅ 并行编写独立模块测试 |
| ❌ 中断后重新开始 | ✅ 自动断点续传 |
| ❌ 无状态可视化 | ✅ 完整状态管理 |

**DAG 模式优势**：
- ✅ 测试被中断可自动继续（不浪费已完成的工作）
- ✅ 并行编写独立模块测试（大幅提速）
- ✅ 状态可视化（查看进度和耗时）
- ✅ 文件冲突检测（避免并发修改冲突）

---

## 📊 与其他 Commands 对比

| Command | 用途 | 范围 | 工作流 |
|---------|------|------|--------|
| `/test-plan` | 测试规划和批量编写 | 全项目 | **DAG 模式** ⭐ |
| `/test-unit` | 运行并修复单元测试 | 单次运行 | 即时执行 |
| `/test-integration` | 运行并修复集成测试 | 单次运行 | 即时执行 |
| `/test-e2e` | 运行并修复E2E测试 | 单次运行 | 即时执行 |
| `/create-e2e-test` | 为单个功能生成E2E测试 | 单个功能 | 即时执行 |

**建议顺序**：
1. 运行 `/test-plan` 生成测试规划和任务
2. 执行 DAG 任务自动编写所有测试
3. 日常开发中使用 `/test-unit`, `/test-integration`, `/test-e2e` 运行测试

---

## 📚 相关文档

- **DAG 任务格式**：`@templates/workflow/DAG_TASK_FORMAT.md`
- **任务工作流架构**：`@CLAUDE.md` 的"任务工作流架构"章节
- **batchcc 脚本**：`~/.claude/my-scripts/batch/README_DAG.md`
- **测试命令**：`@test-unit.md`, `@test-integration.md`, `@test-e2e.md`

---

## 开始执行

现在开始测试规划，采用 DAG 任务编排模式。

**执行步骤**：
1. ✅ **分析项目测试现状**，识别测试缺口
2. ✅ **自主决策测试策略**，选择合适的测试类型和范围
3. ✅ **生成任务文件**（task-add-test + .test-tasks/*.md）
4. ✅ **输出任务文件路径和执行命令**

**生成的任务文件将通过 `batchcc.py` 完全自动化执行**，无需人工干预。

**关键要求**：
- ✅ 使用 DAG 格式生成任务文件
- ✅ 任务文件模块化（使用 `@文件引用`）
- ✅ 明确的 STAGE 编排（基础设施串行、测试编写并行、验证串行）
- ✅ 每个 TASK 有清晰的依赖和输出
- ✅ 文件范围明确（支持冲突检测）
- ✅ 验证命令完整
- ✅ 务实的测试策略（专注核心价值）
