# 全面健康检查（Comprehensive Health Check）

> **用途**：项目全面深度体检，适合定期检查或接手项目时使用
>
> **核心价值**：
> - 🔍 真正的深度分析（实际运行测试，而非静态扫描）
> - 🤖 完全自动化执行（AI 自主诊断和决策）
> - 📊 结构化问题报告（按优先级分类，可直接执行修复）
> - 🔄 两阶段工作流（诊断 → 治疗，中间可人工决策）

---

## 🎯 核心目标

生成一套 DAG 任务编排文件，自动化完成：

1. **测试健康度检查** - 运行所有测试，分析失败原因和覆盖率
2. **代码质量评估** - 检查复杂度、文件大小、类型注解
3. **架构一致性验证** - 检查分层、循环依赖、错误处理
4. **文档准确性核对** - 对比文档与实际代码状态

最终输出：
- `docs/health-check/YYYY-MM-DD/SUMMARY.md` - 问题汇总报告
- `task-refactor` - 自动生成的修复任务文件（可选执行）

---

## 🚀 使用方式

```bash
# 1. 生成健康检查任务编排
/comprehensive-health-check

# 2. 执行健康检查（完全自动化）
python batchcc.py task-health-check

# 3. 查看诊断报告
cat docs/health-check/$(date +%Y-%m-%d)/SUMMARY.md

# 4. 如果需要修复，执行自动生成的修复任务
git commit -am "Before refactor"
python batchcc.py task-refactor
```

---

## 🤖 自主执行原则

本命令生成的任务文件将通过 `batchcc.py` **完全自动化、无人值守**地执行。

### Claude 在健康检查任务中的行为准则

#### ✅ 应该做的
1. **自主诊断**：深入分析代码、测试、文档的实际状态
2. **自主判断**：基于问题严重性（Critical/High/Medium/Low）分类
3. **自主决策**：决定哪些问题需要立即修复，哪些仅记录
4. **直接执行**：在修复阶段直接实施修复方案
5. **记录理由**：在 SUMMARY.md 中说明判断依据

#### ❌ 不应该做的
1. 询问"是否需要修复这个问题？"
2. 列出多种修复方案让用户选择
3. 在任务中设计交互式环节

### 诊断阶段的决策标准

**自动分级标准**：

- **Critical（阻塞性）**：
  - 核心测试失败（登录、支付等）
  - 严重的循环依赖
  - 数据安全问题
  - → 必须修复，生成到 task-refactor

- **High（高影响）**：
  - 重要功能缺少测试
  - 文档严重过时
  - 明显的性能问题
  - → 建议修复，生成到 task-refactor

- **Medium（中等影响）**：
  - 代码重复较多
  - 部分文档缺失
  - 命名不规范
  - → 仅记录，不自动修复

- **Low（低优先级）**：
  - 代码风格不统一
  - 注释不足
  - 可选的优化
  - → 仅记录，不自动修复

### 修复阶段的决策原则

**自动修复范围**（无需询问）：

- ✅ 修复失败的测试（明确的断言错误）
- ✅ 更新过时的文档（有明确的新状态）
- ✅ 重构循环依赖（有明确的方向）
- ✅ 添加缺失的测试（有明确的功能逻辑）

**不自动修复范围**（需标记失败）：

- ❌ 业务逻辑调整（需要业务规则判断）
- ❌ 架构方案选择（有多种同等方案）
- ❌ 第三方库升级（需要兼容性评估）

**示例对比**：

❌ **错误做法**：
```
发现3个问题：
1. 用户测试失败
2. 订单文档过时
3. 支付模块循环依赖

需要我：
1. 修复测试？
2. 更新文档？
3. 重构支付模块？

请告诉我优先修复哪个！
```

✅ **正确做法**：
```
发现3个问题：
1. 用户测试失败（Critical）
2. 订单文档过时（High）
3. 支付模块循环依赖（Critical）

决策：优先级 Critical > High
- 循环依赖阻塞代码维护 → 优先修复
- 测试失败影响信心 → 其次修复
- 文档过时不阻塞开发 → 最后修复

正在生成修复任务到 task-refactor...

修复阶段将自动按此优先级执行。
```

---

## 📋 执行策略

### 第一步：了解项目状态

快速读取关键信息（如果存在）：
- `FEATURE_CODE_MAP.md` - 功能模块和代码位置
- `docs/testing/COVERAGE_MAP.md` - 测试文件分布
- `PROJECT_STATUS.md` - 已知技术债务
- `package.json` / `pyproject.toml` - 技术栈和脚本

**目标**：识别核心模块、测试类型、项目规模

### 第二步：生成任务编排文件

生成以下文件结构：

```
项目根目录/
├── task-health-check                    # 主任务文件（精简，使用 @引用）
├── task-refactor                        # 修复任务（stage-5 自动生成）
│
├── .health-check-tasks/                 # 检查任务细节
│   ├── stage-1-test-health.md          # 测试检查任务
│   ├── stage-2-code-quality.md         # 代码质量任务
│   ├── stage-3-architecture.md         # 架构检查任务
│   ├── stage-4-documentation.md        # 文档检查任务
│   └── stage-5-summary.md              # 汇总和生成修复任务
│
└── .refactor-tasks/                     # 修复任务（stage-5 自动生成）
    └── (根据发现的问题自动生成)
```

**主任务文件格式**（`task-health-check`）：

```markdown
# 项目健康检查任务
# 生成时间: YYYY-MM-DD

## STAGE ## name="test-health" mode="parallel" max_workers="4"
# 测试健康检查（并行执行）

@.health-check-tasks/stage-1-test-health.md

## STAGE ## name="code-quality" mode="parallel" max_workers="4"
# 代码质量检查（并行执行）

@.health-check-tasks/stage-2-code-quality.md

## STAGE ## name="architecture" mode="serial"
# 架构一致性检查（串行执行）

@.health-check-tasks/stage-3-architecture.md

## STAGE ## name="documentation" mode="parallel" max_workers="2"
# 文档一致性检查（并行执行）

@.health-check-tasks/stage-4-documentation.md

## STAGE ## name="summary" mode="serial"
# 汇总报告和生成修复任务（串行执行）

@.health-check-tasks/stage-5-summary.md
```

**⚠️ 关键格式要求**：

**STAGE 格式**：
- ✅ 使用 `## STAGE ##`（两个 `##` 标记），不是 `## STAGE 1:`
- ✅ 必须包含 `name="..."` 和 `mode="serial|parallel"` 属性
- ✅ 并行模式可选 `max_workers="N"` 指定并发数

**TASK 格式**：
- ✅ 使用 `## TASK ##`（两个 `##` 标记），任务描述在下一行
- ❌ 错误：`## TASK: 任务名称` 或 `## TASK ## 任务名称`
- ✅ 正确：`## TASK ##` 换行后写任务描述

**示例**：
```markdown
## TASK ##
E2E测试健康检查

运行项目的 E2E 测试套件并分析结果...

文件: tests/e2e/**/*.test.ts
验证: 检查报告文件是否存在
```

**详细格式参考**：`@templates/workflow/DAG_TASK_FORMAT.md`

### 第三步：设计任务内容

**关键原则**：

#### Stage 1: 测试健康检查（建议 60-100 行）

**为项目中的每种测试类型生成检查任务**（E2E、单元测试、集成测试等）

**每个任务的核心流程**：
1. 运行对应类型的测试（根据项目配置自动查找测试命令）
2. 分析测试结果（通过率、失败原因、超时、覆盖率）
3. 识别问题并分级（Critical/High/Medium/Low）
4. 生成报告到：`docs/health-check/YYYY-MM-DD/test-[类型].md`

**关键要求**：
- ⚠️ 使用 `## TASK ##`（两个 `##` 标记），任务描述在下一行
- ❌ 错误：`## TASK: 任务名称` 或 `## TASK ## 任务名称`
- ✅ 正确：`## TASK ##` 换行后写任务描述
- 使用 `文件:` 指定相关测试文件范围（用于冲突检测）
- **不要硬编码测试命令**，让 AI 查找项目的测试脚本
- **不要内嵌报告格式模板**，只说明报告应包含的关键信息

**TASK 格式示例**：
```markdown
## TASK ##
E2E测试健康检查

运行项目的 E2E 测试套件并分析结果...

文件: tests/e2e/**/*.test.ts
验证: 检查报告文件是否存在
```

#### Stage 2: 代码质量检查（建议 60-100 行）

**为识别出的核心模块生成代码质量检查任务**

**每个任务关注的维度**：
- 代码规模（文件大小、函数长度、嵌套层次）
- 类型注解完整性（TypeScript strict mode, Python mypy）
- 注释和文档质量
- 是否遵循项目的架构模式

**关键要求**：
- 让 AI 自主决定抽样哪些文件（建议 3-5 个关键文件）
- 让 AI 自主决定使用哪些工具检查（tsc, mypy, pylint等）
- **不要硬编码工具命令**，让 AI 根据项目配置决定
- 聚焦实际问题，避免追求完美（80分原则）

#### Stage 3: 架构一致性检查（建议 80-120 行）

**检查项目整体架构质量**

**建议检查的维度**：
- 分层架构一致性（如果项目采用分层架构）
- 循环依赖识别（使用依赖分析工具）
- 错误处理一致性（是否有统一的错误处理机制）
- 依赖流动方向（是否有反向依赖）

**关键要求**：
- 串行执行（需要综合前面阶段的结果）
- 聚焦实际架构问题，而非理论最佳实践
- **不要硬编码分析工具命令**，让 AI 选择合适的工具

#### Stage 4: 文档一致性检查（建议 60-100 行）

**验证文档与实际代码的一致性**

**建议检查的文档**：
- `FEATURE_CODE_MAP.md` - 功能映射准确性
- `PROJECT_STATUS.md` - 项目状态准确性
- `docs/testing/COVERAGE_MAP.md` - 测试覆盖度地图准确性
- 其他关键项目文档

**关键要求**：
- 并行执行（文档检查互不依赖）
- 只检查实际存在的文档（用 AI 先判断文档是否存在）
- 重点验证文档与代码是否一致，而非文档是否完美

#### Stage 5: 汇总报告和自动生成修复任务（建议 100-150 行，不超过 180 行）⚠️

**这是最关键的阶段**，包含两个核心任务：

**任务 1：生成汇总报告**
1. 读取所有前面阶段生成的报告文件
2. 按优先级汇总所有问题（Critical/High/Medium/Low）
3. 计算整体健康评分（参考 README 中的评分标准）
4. 生成 `SUMMARY.md` 到 `docs/health-check/YYYY-MM-DD/`
5. 输出友好的控制台提示

**SUMMARY.md 应该包含**：
- 整体评分和分项评分
- 分级问题清单（每个问题有 ID、描述、位置、影响）
- 统计信息
- 建议的修复顺序
- 下一步指引

**任务 2：自动生成修复任务文件**

根据发现的问题自动生成修复任务到 `.refactor-tasks/` 和 `task-refactor`：

**生成逻辑**（精简描述，不要内嵌完整示例）：
- 按问题类型分组（测试失败、循环依赖、缺失测试、过时文档、架构模式迁移等）
- 为每类问题生成独立的任务文件（文件名、包含的关键信息）
- 生成 `task-refactor` 主文件，使用 STAGE 组织任务
- Critical 问题串行修复（STAGE 1），High/Medium 并行修复（STAGE 2-3）

**决策原则**：
- Critical 和 High 问题：如果修复方案明确，自动生成任务
- Medium/Low 问题：仅记录到 SUMMARY.md，不生成修复任务
- 需要人工决策的问题：标记在 SUMMARY.md，说明原因

**🚫 重要提醒**：
- **不要内嵌完整的修复任务示例**（每个示例>20行）
- **不要内嵌完整的报告格式模板**（>30行的模板）
- 只说明生成逻辑、包含的关键信息、决策原则

---

## 💎 关键要求（必读）

### 🚫 严格禁止事项

#### 禁止1：内嵌详细示例（最重要）⛔

**问题根源**：内嵌大量示例会导致任务文件膨胀（>200行），违背精简原则。

**严格禁止**：
- ❌ 在任务文件中内嵌完整的修复任务示例（>20行）
- ❌ 内嵌多种场景的详细报告格式模板
- ❌ 内嵌多个"如果...则生成...md"的完整示例

**正确做法**：
- ✅ 只说明生成逻辑和原则（< 10行）
- ✅ 列出要包含的关键信息点
- ✅ 引用外部模板文件（如果需要）

**示例对比**：

❌ **错误**（内嵌完整示例，100+行）：
```markdown
**如果有测试失败问题** → 生成 `.refactor-tasks/fix-tests.md`：
\`\`\`markdown
# 修复测试失败

## TASK: 修复 E2E 测试失败
文件: [失败测试涉及的文件]

修复以下失败的 E2E 测试：

1. [测试名称] - [失败原因]
2. [测试名称] - [失败原因]

执行步骤：
1. 分析失败原因（查看日志：logs/dev-full.log）
2. 修复代码
3. 运行测试验证
... (50行示例)
\`\`\`
```

✅ **正确**（只说明逻辑，< 10行）：
```markdown
根据问题类型自动生成修复任务文件到 `.refactor-tasks/`：

- 测试失败 → fix-tests.md（失败列表、原因、验证命令）
- 循环依赖 → fix-circular-deps.md（依赖路径、重构方案、验证）
- 缺失测试 → add-tests.md（模块列表、覆盖率目标、验证）
- 文档过时 → update-docs.md（问题列表、更新内容、验证）
```

#### 禁止2：硬编码具体命令 ⛔

**问题根源**：不同项目的测试命令、工具配置不同，硬编码会失去灵活性。

**严格禁止**：
- ❌ `运行命令：pnpm test:e2e --reporter=json`
- ❌ `执行：pytest -c tests/config/pytest.ini pythonapi/`
- ❌ `运行：npx madge --circular src/`

**正确做法**：
- ✅ 运行 E2E 测试套件（根据项目的测试脚本）
- ✅ 运行 Python 测试（查找项目的 pytest 配置）
- ✅ 使用依赖分析工具检查循环依赖

**示例对比**：

❌ **错误**：
```markdown
1. **执行测试**：
   - 运行命令：`pnpm test:e2e --reporter=json --reporter=html`
   - 运行命令：`pytest -c tests/config/pytest.ini pythonapi/`
```

✅ **正确**：
```markdown
1. **执行测试**：
   - 运行 E2E 测试套件（查找 package.json 中的测试脚本）
   - 运行 Python 测试套件（根据项目的 pytest 配置）
```

#### 禁止3：过度详细的步骤指导 ⛔

**问题根源**：详细步骤限制了 AI 的自主决策空间。

**严格禁止**：
- ❌ 编号步骤超过 5 步
- ❌ 指定读取文件的具体行数
- ❌ 指定具体的检查顺序和方法

**正确做法**：
- ✅ 描述要达成的目标
- ✅ 列出需要关注的维度
- ✅ 给出问题分级的原则

---

### 📏 字数和格式约束

**严格限制**：
- ⚠️ **Stage 1-4 任务文件**：建议 60-120 行
- ⚠️ **Stage 5 汇总任务**：建议 100-150 行（不超过 180 行）
- ⚠️ **单个 TASK 描述**：建议 20-40 行

**如果超过建议行数**：
- 检查是否内嵌了详细示例 → 删除，改为逻辑说明
- 检查是否有过多的重复内容 → 合并同类项
- 检查是否有不必要的详细步骤 → 精简为方法指导

---

### 输出路径统一规范 🎯

**必须遵守**：
- ✅ 所有阶段的报告统一输出到：`docs/health-check/$(date +%Y-%m-%d)/`
- ✅ 使用 `YYYY-MM-DD` 占位符（在任务执行时被替换）
- ✅ 不要将报告输出到 `.health-check-tasks/` 目录
- ✅ 验证命令必须与实际输出路径一致

**为什么重要**：
- Stage 5 需要读取所有前面阶段的报告文件
- 如果输出路径不统一，汇总任务会找不到文件

---

### AI 自主决策空间 🤖

**核心原则**：提供方法指导，而非详细步骤

❌ **不要写**：
```markdown
1. 运行 pytest tests/xxx/ -v
2. 读取输出的第3-10行
3. 如果包含 "FAILED"，则记录为 Critical
4. 统计失败数量，计算通过率
```

✅ **应该写**：
```markdown
运行项目的测试，分析测试结果：
- 识别失败的测试及其原因
- 评估测试质量（是否过时、是否缺失关键场景）
- 按严重程度分级（Critical/High/Medium/Low）
```

### 任务文件组织

1. **主任务文件精简** - `task-health-check` 只包含 STAGE 定义和 `@引用`
2. **详细任务模块化** - 每个 stage 的任务放在独立文件
3. **问题ID编码** - 使用 `critical-1`, `high-2` 等，便于跨文件引用
4. **文件范围明确** - 使用 `文件:` 指定任务涉及的文件（用于冲突检测）

### 修复任务自动生成

在 Stage 5 中自动生成 `task-refactor` 和 `.refactor-tasks/*.md`：

1. **按问题类型分组** - 测试失败、循环依赖、缺失测试、过时文档等
2. **按优先级编排** - Critical 串行修复，High/Medium 并行修复
3. **明确文件范围** - 避免并发修改冲突
4. **可验证** - 每个修复任务都有验证命令

---

## 📚 参考资料

- **DAG 任务格式**：`@templates/workflow/DAG_TASK_FORMAT.md`
- **任务工作流架构**：`@CLAUDE.md` 的"任务工作流架构"章节
- **命令设计原则**：`@CLAUDE.md` 的"命令设计原则"章节
