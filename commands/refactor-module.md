# 模块级重构（Module-Level Refactoring）

> **用途**：优化单个模块内的协作关系和数据流
>
> **核心特性**：
> - ✅ DAG 任务编排（串行/并行混合执行）
> - ✅ 自动断点续传（重构被中断可自动继续）
> - ✅ 状态管理（可视化进度和耗时）
> - ✅ 预览执行计划（`--dry-run`）
>
> **适用场景**：
> - 类职责混乱
> - 循环依赖
> - 数据流复杂
> - 单个模块优化

---

## 🎯 工作原理

采用 **DAG 任务编排模式**：

```
/refactor-module "模块名"
    ↓
生成 task-refactor-module-[模块名]（DAG 格式）
    ↓
输出任务文件路径和执行命令
    ↓
    ↓
python batchcc.py task-refactor-module-[模块名]（执行）
    ↓
自动执行（支持中断和续传）：
  - STAGE 1（串行）: 分析和规划
  - STAGE 2（串行）: 重构实施
  - STAGE 3（串行）: 测试验证
  - STAGE 4（串行）: 文档更新
    ↓
✅ 模块重构完成
```

---

## 🚀 使用方法

```bash
# 步骤1: 生成模块重构任务文件
/refactor-module "user"  # 指定要重构的模块名

# 步骤2: 预览执行计划
python batchcc.py task-refactor-module-user --dry-run

# 步骤3: 执行重构（自动断点续传）
git commit -am "Before refactor user module"
python batchcc.py task-refactor-module-user

# 步骤4: 如果中断，直接再次运行（自动从断点继续）
python batchcc.py task-refactor-module-user

# 步骤5: 查看执行状态
cat task-refactor-module-user.state.json
```

---

## 🤖 自主执行原则

本命令生成的任务文件将通过 `batchcc.py` **完全自动化、无人值守**地执行。

### Claude 在模块重构任务中的行为准则

#### ✅ 应该做的
1. **自主分析**：深入理解模块内的类职责、依赖关系、数据流
2. **自主决策**：基于单一职责原则和最小依赖原则选择重构方案
3. **直接执行**：不询问用户，直接实施选定的重构方案
4. **记录理由**：在日志中说明重构决策依据
5. **增量验证**：每个小步骤完成后运行单元测试

#### ❌ 不应该做的
1. 询问"应该如何拆分这个类？"
2. 列出多种拆分方案让用户选择
3. 在任务中设计交互式环节

### 模块重构决策标准

**职责拆分原则**：

1. **单一职责**：
   - 一个类只负责一件事
   - 类的修改只有一个理由
   - 方法数量控制在 10 个以内

2. **最小依赖**：
   - 减少类之间的耦合
   - 优先依赖接口而非实现
   - 消除循环依赖

3. **清晰边界**：
   - 数据和行为放在一起
   - 避免贫血模型
   - 明确的输入输出

**自动决策范围**（无需询问）：

- ✅ 拆分 God Class（有明确的职责边界）
- ✅ 提取重复逻辑到工具类（有明确的复用场景）
- ✅ 消除循环依赖（有明确的依赖方向）
- ✅ 优化方法参数（参数过多时提取参数对象）

**需标记失败的情况**：

- ❌ 多种拆分方式同等合理（如按功能 vs 按层次）
- ❌ 需要业务规则判断（如某个逻辑属于哪个模块）
- ❌ 涉及跨模块的数据迁移

**示例对比**：

❌ **错误做法**：
```
分析 UserService 类：
- 有 25 个方法
- 包含：CRUD、权限、邮件、统计

可能的拆分方案：
1. 按功能拆分：UserCRUD + UserAuth + UserEmail + UserStats
2. 按层次拆分：UserService + UserRepository + UserValidator
3. 保持现状，只做方法重构

你希望用哪种方案？
```

✅ **正确做法**：
```
分析 UserService 类：
- 有 25 个方法（职责过多）
- 包含：CRUD、权限、邮件、统计

决策：按功能拆分
理由：
- 各功能独立，无强耦合
- 邮件、统计可能复用到其他模块
- 拆分后每个类 ≤ 10 方法

拆分方案：
- UserService：核心 CRUD（5 方法）
- UserAuthService：权限验证（3 方法）
- UserEmailService：邮件通知（4 方法）
- UserStatsService：统计分析（6 方法）

正在实施重构...
- STAGE 1: 提取 UserEmailService
- STAGE 2: 提取 UserStatsService
- STAGE 3: 提取 UserAuthService
- STAGE 4: 测试验证
```

### 失败处理

**真正无法决策时**（如需要业务知识判断），应该：

1. 标记任务为 `failed`
2. 说明无法决策的具体原因（如："无法判断某逻辑属于用户模块还是订单模块"）
3. 列出可选方案和各自的利弊
4. 建议用户在任务描述中补充业务规则

---

## 📋 执行策略

### 核心目标

生成以下文件结构：

```
项目根目录/
├── task-refactor-module-[模块名]           # 主任务文件（精简）
├── task-refactor-module-[模块名].state.json # 状态文件（自动生成）
│
└── .refactor-tasks/module-[模块名]/        # 模块重构任务细节
    ├── stage-1-analysis.md                 # 分析和规划
    ├── stage-2-refactor.md                 # 重构实施
    ├── stage-3-test.md                     # 测试验证
    └── stage-4-documentation.md            # 文档更新
```

---

## 执行步骤

### 步骤1: 分析模块

**分析内容**：
- 读取模块相关文档（README.md, TECHNICAL.md）
- 读取 ADR 索引（docs/decisions/INDEX.md，如果存在）
- 识别问题：
  - 文件职责不清？
  - 循环依赖？
  - 数据流混乱？
  - 耦合过度？

**输出**：
- 模块现状分析
- 问题诊断
- 数据流图（当前）

---

### 步骤2: 生成 task-refactor-module-[模块名] 主文件

**参考模板**：`@templates/workflow/DAG_TASK_FORMAT.md`

**任务文件结构**：

```markdown
# 模块重构任务 - [模块名]

## 模块背景
[简要说明模块情况和重构原因]

## 重构目标
[列出重构的核心目标]

## STAGE ## name="analysis" mode="serial"
# 🎯 阶段目标：分析和规划
# 📥 输入：当前模块代码
# 📤 输出：重构计划和数据流图
# 🔗 为下一阶段提供：明确的重构目标和方案

@.refactor-tasks/module-[模块名]/stage-1-analysis.md

## STAGE ## name="refactor" mode="serial"
# 🎯 阶段目标：重构实施
# 📥 输入：重构计划
# 📤 输出：重构后的代码
# 🔗 为下一阶段提供：新架构的模块代码

@.refactor-tasks/module-[模块名]/stage-2-refactor.md

## STAGE ## name="test" mode="serial"
# 🎯 阶段目标：测试验证
# 📥 输入：重构后的代码
# 📤 输出：测试通过
# 🔗 为下一阶段提供：验证通过的代码

@.refactor-tasks/module-[模块名]/stage-3-test.md

## STAGE ## name="documentation" mode="serial"
# 🎯 阶段目标：文档更新
# 📥 输入：重构完成的模块
# 📤 输出：文档更新完成

@.refactor-tasks/module-[模块名]/stage-4-documentation.md
```

---

### 步骤3: 生成各阶段的详细任务文件

#### .refactor-tasks/module-[模块名]/stage-1-analysis.md

分析和规划任务：

```markdown
## TASK ##
分析模块结构和职责

**📖 背景**：
理解模块当前状态，识别问题

**🔨 要做什么**：
1. 读取模块所有文件
2. 分析文件职责和依赖关系
3. 识别问题：
   - 职责不清的类
   - 循环依赖
   - 数据流混乱
   - 过度耦合

**✅ 完成标志**：
- 问题清单完成
- 数据流图绘制完成

**📤 输出状态**：
- ✅ 模块现状清晰

文件: src/[模块名]/**/*
验证: echo "分析完成"

## TASK ##
制定重构计划

**📖 背景**：
基于分析结果制定重构方案

**🔨 要做什么**：
1. 设计目标架构
2. 定义文件职责
3. 规划重构步骤
4. 评估风险

**✅ 完成标志**：
- 目标架构清晰
- 重构步骤明确
- 风险评估完成

**📥 输入依赖**：
- ⬆️ 模块分析完成

**📤 输出状态**：
- ✅ 重构计划就绪

文件: .refactor-tasks/module-[模块名]/refactor-plan.md
验证: [ -f .refactor-tasks/module-[模块名]/refactor-plan.md ]
```

#### .refactor-tasks/module-[模块名]/stage-2-refactor.md

重构实施任务：

```markdown
## TASK ##
重构文件职责

**📖 背景**：
按照重构计划拆分和重组文件

**🔨 要做什么**：
1. 拆分职责混乱的类
2. 提取重复代码
3. 优化依赖关系
4. 重构数据流

**✅ 完成标志**：
- 每个文件职责单一
- 依赖关系清晰
- 数据流优化

**📥 输入依赖**：
- ⬆️ 重构计划就绪

**📤 输出状态**：
- ✅ 文件职责清晰

文件: src/[模块名]/**/*
验证: echo "重构完成"

## TASK ##
解决循环依赖

**📖 背景**：
消除模块内的循环依赖

**🔨 要做什么**：
1. 识别循环依赖
2. 引入抽象层打破循环
3. 调整依赖方向

**✅ 完成标志**：
- 无循环依赖
- 依赖流动单向

**📥 输入依赖**：
- ⬆️ 文件职责清晰

**📤 输出状态**：
- ✅ 循环依赖解决

文件: src/[模块名]/**/*
验证: echo "循环依赖已解决"

## TASK ##
优化接口设计

**📖 背景**：
简化和优化模块对外接口

**🔨 要做什么**：
1. 精简公开接口
2. 隐藏实现细节
3. 保持向后兼容

**✅ 完成标志**：
- 接口简洁明了
- 实现细节隐藏
- 兼容性保持

**📥 输入依赖**：
- ⬆️ 循环依赖解决

**📤 输出状态**：
- ✅ 接口优化完成

文件: src/[模块名]/index.ts
验证: echo "接口优化完成"
```

#### .refactor-tasks/module-[模块名]/stage-3-test.md

测试验证任务：

```markdown
## TASK ##
运行模块测试

**📖 背景**：
验证重构后功能正常

**🔨 要做什么**：
1. 运行模块单元测试
2. 运行集成测试
3. 检查测试覆盖率

**✅ 完成标志**：
- 所有测试通过
- 覆盖率不降低

**📥 输入依赖**：
- ⬆️ 重构完成

**📤 输出状态**：
- ✅ 测试全部通过

文件: tests/[模块名]/**/*.test.ts
验证: npm test -- --testPathPattern=[模块名]

## TASK ##
验证接口兼容性

**📖 背景**：
确保重构后接口兼容

**🔨 要做什么**：
1. 检查公开接口
2. 验证向后兼容性
3. 测试依赖此模块的其他模块

**✅ 完成标志**：
- 接口兼容性验证通过
- 依赖模块正常工作

**📥 输入依赖**：
- ⬆️ 测试全部通过

**📤 输出状态**：
- ✅ 接口兼容性确认

文件: src/[模块名]/index.ts
验证: npm test
```

#### .refactor-tasks/module-[模块名]/stage-4-documentation.md

文档更新任务：

```markdown
## TASK ##
更新 TECHNICAL.md

**📖 背景**：
更新模块架构文档

**🔨 要做什么**：
1. 更新模块职责表
2. 更新数据流图
3. 更新接口说明

**✅ 完成标志**：
- TECHNICAL.md 反映新架构

**📥 输入依赖**：
- ⬆️ 重构和测试完成

**📤 输出状态**：
- ✅ 技术文档更新完成

文件: TECHNICAL.md
验证: [ -f TECHNICAL.md ]

## TASK ##
更新 FEATURE_CODE_MAP.md

**📖 背景**：
更新功能代码映射

**🔨 要做什么**：
1. 更新模块文件位置
2. 更新功能映射

**✅ 完成标志**：
- FEATURE_CODE_MAP.md 更新

**📥 输入依赖**：
- ⬆️ 重构完成

**📤 输出状态**：
- ✅ 功能映射更新完成

文件: FEATURE_CODE_MAP.md
验证: [ -f FEATURE_CODE_MAP.md ]

## TASK ##
创建模块重构 ADR（可选）

**📖 背景**：
记录重构的架构决策

**🔨 要做什么**：
1. 创建 ADR 文档（如果有重要架构变化）
2. 记录重构原因和决策
3. 更新 docs/decisions/INDEX.md

**✅ 完成标志**：
- ADR 文档创建完成（如有必要）

**📥 输入依赖**：
- ⬆️ 重构完成

**📤 输出状态**：
- ✅ ADR 文档完成（如适用）

文件: docs/decisions/ADR-XXXX-[模块名]-refactor.md
验证: echo "ADR 创建完成或不需要"
```

---

## 🎯 重要约束

### 1. 模块边界 ⚠️
- 仅重构单个模块
- 不调整跨模块关系
- 保持模块对外接口兼容

### 2. 测试驱动 ⚠️
- 重构前运行测试确保通过
- 重构后运行测试验证功能
- 测试不过不提交

### 3. 不要过度设计 ⚠️
- **优先**：解决现有问题
- **避免**：为"可能的未来"设计
- **原则**：够用即可

### 4. Git 里程碑 ⚠️
- 重构前确保 Git 工作区干净
- 建议在任务中添加提交点
- 方便回滚

---

## 💡 核心价值

**相比传统模块重构**：

| 传统流程 | DAG 模式 |
|---------|----------|
| ❌ 手动分步执行 | ✅ 自动编排执行 |
| ❌ 中断后重新开始 | ✅ 自动断点续传 |
| ❌ 手动跟踪进度 | ✅ 状态可视化 |
| ❌ 无执行计划 | ✅ 预览执行计划 |

**DAG 模式优势**：
- ✅ 重构被中断可自动继续
- ✅ 状态可视化（查看进度和耗时）
- ✅ 系统化执行（不遗漏步骤）

---

## 📊 何时升级

| 场景 | 推荐命令 |
|------|---------|
| 单个文件重构 | `/refactor` |
| 单个模块重构 | `/refactor-module` ⭐ |
| 多个模块重构 | `/refactor-project` |
| 全项目架构调整 | `/refactor-project` |

---

## 📚 相关文档

- **DAG 任务格式**：`@templates/workflow/DAG_TASK_FORMAT.md`
- **项目级重构**：`@refactor-project.md`
- **任务工作流架构**：`@CLAUDE.md` 的"任务工作流架构"章节
- **batchcc 脚本**：`~/.claude/my-scripts/batch/README_DAG.md`

---

## 开始执行

现在开始模块级重构，采用 DAG 任务编排模式。

**执行步骤**：
1. ✅ **深入分析模块**，识别重构需求和风险点
2. ✅ **自主决策重构方案**，选择最优实现方式
3. ✅ **生成任务文件**（task-refactor-module-[模块名] + .refactor-tasks/module-[模块名]/*.md）
4. ✅ **输出任务文件路径和执行命令**

**生成的任务文件将通过 `batchcc.py` 完全自动化执行**，无需人工干预。

**关键要求**：
- ✅ 使用 DAG 格式生成任务文件
- ✅ 任务文件模块化（使用 `@文件引用`）
- ✅ 明确的 STAGE 编排（通常串行）
- ✅ 每个 TASK 有清晰的依赖和输出
- ✅ 文件范围明确
- ✅ 验证命令完整
