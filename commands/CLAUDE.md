# CLAUDE.md - Command 设计指南

> 本文档指导 Claude Code 如何编写和优化项目中的斜杠命令

## 项目核心

精简高效的斜杠命令库，包含17个命令文件，遵循"**目标导向、自主执行**"的设计理念。

**核心价值**：为 Claude Code 提供清晰的意图指导而非具体步骤模板，让 AI 发挥创造性解决问题。

## 命令设计原则 ⭐

### 四大核心理念

1. **意图清晰性** - 每个命令明确表达要解决的核心问题
   - 用户想达成什么目标？
   - 核心价值是什么？

2. **执行自主权** - 提供方法指导而非具体步骤
   - 告诉 AI "做什么"和"为什么"，而非"怎么做"
   - 让 AI 根据实际情况选择最佳实现路径

3. **约束平衡** - 在灵活性与规范性之间找到平衡
   - 必要的约束：质量标准、技术限制、禁止操作
   - 充分的自由：实现细节、工具选择、优化决策

4. **务实导向** - 避免过度设计，专注实际价值
   - 解决真实痛点，而非追求"完美"
   - 简单够用优于复杂完美

### 优化成果标准

- **精简高效**：命令文件建议 100 行以下（非硬性要求）
- **职责清晰**：每个命令解决一类问题，零重复
- **模板分离**：详细示例放在 templates，命令只包含意图指导
- **易于组合**：命令间可配合使用形成工作流

## 命令质量检查清单

编写或优化命令时，检查以下标准：

### 结构质量
- [ ] 文件精简（建议100行以下，非硬性要求）
- [ ] 职责单一（一个命令解决一类问题）
- [ ] 目标明确（清晰的问题定义和期望输出）
- [ ] 无重复（与其他命令职责不重叠）

### 设计质量
- [ ] 意图清晰（一句话能说明核心目的）
- [ ] 约束适度（必要的限制，充分的自由）
- [ ] 可组合（能与其他命令配合使用）
- [ ] 实用性（解决真实场景的痛点）

### 内容质量
- [ ] 无详细步骤模板（避免限制 AI 发挥）
- [ ] 无大量内嵌示例（应放 templates）
- [ ] 有清晰的输出要求
- [ ] 有必要的技术约束

## 命令编写指导

### 推荐结构

```markdown
# 命令名

## 目标
一句话说明这个命令解决什么问题

## 执行方式
提供方法指导（而非具体步骤）：
- 分析什么
- 关注什么
- 生成什么

## 约束条件
明确的边界和限制：
- 必须遵守的规范
- 禁止的操作
- 技术要求

## 输出要求
期望的结果格式和质量标准

## 模板引用（可选）
如需参考模板：@templates/...
```

### 编写陷阱

**❌ 避免这些做法：**

1. **写成详细步骤模板**
   ```markdown
   ❌ 第一步：运行 git status
   ❌ 第二步：读取 package.json
   ❌ 第三步：分析依赖关系
   ```
   ✅ 应该：分析项目依赖状态，识别过时或冲突的包

2. **内嵌大量示例**
   ```markdown
   ❌ 示例1：...50行代码...
   ❌ 示例2：...50行代码...
   ```
   ✅ 应该：参考 @templates/docs/README_TEMPLATE.md

3. **职责模糊**
   ```markdown
   ❌ 分析代码 + 写文档 + 运行测试 + 提交代码
   ```
   ✅ 应该：一个命令解决一类问题，通过组合实现复杂流程

4. **过度约束**
   ```markdown
   ❌ 必须使用 prettier 格式化
   ❌ 必须使用 eslint 检查
   ❌ 注释必须超过30%
   ```
   ✅ 应该：遵循项目现有的代码规范和工具

## 项目约束

### 技术限制
- **禁止调用 `sleep` 命令**（会导致屏幕休眠）
- **禁止创建不必要的文件**（优先编辑现有文件）
- **禁止主动创建文档**（除非用户明确要求）

### 提交规范
- 使用约定式提交格式：`type(scope): description`
- 类型：feat/fix/docs/style/refactor/test/chore
- 完成完整功能后提醒用户提交

## 项目结构

```
.
├── *.md                 # 核心命令文件（27个）
├── templates/           # 模板和规范
│   ├── docs/           # 文档模板（README、TECHNICAL）
│   └── workflow/       # 工作流模板（DAG、规划、调试）
├── archived/            # 归档目录
│   ├── decisions/      # 历史架构决策记录
│   ├── experiments/    # 实验和测试记录
│   └── scripts/        # 已废弃的辅助脚本
├── CLAUDE.md           # 本设计指南
└── README.md           # 项目说明
```

**命令引用机制**：
- 参数传递：`$ARGUMENTS` 变量
- 文件引用：`@文件名`
- 模板引用：`@templates/...`

**归档机制**：
- 活跃使用的命令文件保留在根目录
- 有价值的历史文档归档到 `archived/`
- 详见 `@archived/README.md` 了解归档原则

## 命令分类概览

| 分类 | 数量 | 命令 |
|------|------|------|
| 代码质量 | 1 | code-review |
| 代码重构 | 3 | refactor, refactor-module, refactor-project |
| 项目管理 | 4 | gitcommit, todo-write, todo-doit, **todo-huge-task** |
| 项目分析 | 3 | learn_new_project, catchup, e2e-readiness |
| 文档生成 | 4 | claudemd, techdoc, create-page-doc, doc-organize |
| 文档清理 | 1 | cleanup-docs |
| 方案设计 | 1 | feat-discuss |
| 需求处理 | 1 | prd-to-doc |
| 测试 | 5 | test-plan, test-unit, test-integration, test-e2e, create-e2e-test |
| 健康检查 | 2 | health-check, comprehensive-health-check |

**总计**: 25个核心命令

**归档管理**: 参考 `@archived/README.md` 了解归档原则和流程

### 项目管理命令详解

#### 🔄 任务工作流架构（核心设计）

命令系统采用**三种工作流模式**，根据任务复杂度智能选择：

##### 1️⃣ 即时执行型（Immediate Action）

**适用场景**：单一操作、简单任务、需要即时反馈

**命令示例**：
- `/code-review` - 代码审查
- `/gitcommit` - Git 提交
- `/feat-discuss` - 方案讨论
- `/claudemd` / `/techdoc` - 文档生成
- `/refactor` - 简单重构
- `/test-unit` / `/test-integration` / `/test-e2e` - 测试执行

**工作方式**：Claude 直接分析并执行，即时返回结果

**特点**：
- ✅ 简单快速
- ✅ 适合单一任务
- ✅ 即时反馈
- ❌ 不支持断点续传

---

##### 2️⃣ 串行任务型（Serial Workflow）

**适用场景**：2-5个任务、严格线性流程、需要人工决策

**命令示例**：`/todo-write` → 脚本循环调用 `/todo-doit`

**工作流程**：
```
/todo-write 分析任务并生成 TODO.md
    ↓
脚本循环调用 /todo-doit
    ↓ (任务1完成，自动更新 TODO.md)
    ↓ (任务2完成，自动更新 TODO.md)
    ↓ (任务3完成，自动更新 TODO.md)
    ↓
✅ 所有任务完成（标记：✅ 所有任务已完成）
```

**特点**：
- ✅ 支持断点续传（通过 TODO.md 状态）
- ✅ 适合线性流程
- ✅ 任务间可传递上下文
- ❌ 无法并行执行

**示例**：需求分析 → 设计 → 实现 → 测试

---

##### 3️⃣ DAG 任务型（DAG Workflow）⭐ 最强大

**适用场景**：≥3个任务、可并行执行、需要断点续传、大型重构

**命令示例**：
- `/todo-huge-task` - 大任务智能拆分与编排
- `/comprehensive-health-check` - 项目全面健康检查
- `/refactor-project` - 项目级重构（推荐迁移）
- `/refactor-module` - 模块级重构（推荐迁移）
- `/test-plan` - 测试规划（推荐迁移）

**工作流程**：
```
/todo-huge-task "任务描述"
    ↓
生成 DAG 任务编排文件（task-xxx）
    ↓
python batchcc.py task-xxx
    ↓
智能执行：
  - STAGE 1（串行）: Task 1 → Task 2 → Task 3
  - STAGE 2（并行）: Task 4 || Task 5 || Task 6
  - STAGE 3（串行）: Task 7 → Task 8
    ↓
自动保存状态（task-xxx.state.json）
    ↓
中断后再次运行 → 自动从断点继续
    ↓
✅ 所有 STAGE 和 TASK 完成
```

**核心特性**：
- ✅ **STAGE 粗粒度编排**：串行/并行阶段控制
- ✅ **TASK 细粒度单元**：具体任务定义
- ✅ **文件冲突检测**：自动分析任务文件范围，无冲突并行执行
- ✅ **自动断点续传**：中断后自动继续，无需手动干预
- ✅ **状态管理**：自动保存每个任务的状态、耗时、错误信息
- ✅ **智能调度**：根据依赖关系和冲突情况优化执行计划
- ✅ **预览计划**：`--dry-run` 查看执行计划

**🤖 自主执行原则**（重要）：

DAG 任务体系的核心价值是**完全自动化、无人值守**的执行。

#### 🔒 自动化保证机制

**系统性保证**：`batchcc.py` 作为统一调度器，在调用 Claude 执行每个 TASK 时，自动在任务描述前注入"自动化执行指示"。

这确保了：
- ✅ 每个任务都明确告知 Claude"这是自动化任务"
- ✅ 不依赖任务文件的自动化描述
- ✅ 不依赖 Claude 的"记忆"或上下文理解
- ✅ 统一管理自动化行为准则

**实现方式**：
```python
# batchcc.py 在调用 Claude 时自动添加前缀
automation_prefix = """
⚠️ DAG 自动化任务执行模式

你正在执行通过 batchcc.py 编排的自动化任务。

🤖 必须：完全自主执行，不询问用户
❌ 禁止：询问、列选项、等待确认
"""

enhanced_content = automation_prefix + task_description
```

**好处**：
1. 降低命令文件复杂度（不需要重复写自动化规范）
2. 单一真相源（规范只在 batchcc 中定义）
3. 防御性设计（每次调用都强制传递）

#### 行为准则

**Claude 在 DAG 任务中的行为准则**：

✅ **应该做的**：
- 基于任务目标自主分析问题
- 根据优先级和影响面自主决策最优方案
- 直接执行选定方案，不询问用户
- 在日志中清晰记录决策理由

❌ **不应该做的**：
- 询问"需要我帮您...吗？"
- 列出选项让用户选择
- 等待用户确认才继续
- 在任务中设计交互式环节

**示例对比**：

❌ **错误**：分析后询问用户选择
```
发现3个问题，需要我：
1. 修复配置？
2. 更新文档？
3. 重构代码？
请告诉我从哪里开始！
```

✅ **正确**：自主决策并执行
```
发现3个问题：
1. 配置缺失（阻塞性）
2. 文档过时（中等影响）
3. 代码冗余（低优先级）

决策：优先修复配置缺失，因为这会阻塞其他功能。

正在创建配置文件...
✅ 配置文件已创建

接下来更新文档...
```

**决策失败的处理**：

如果真的无法自主决策（如需要业务规则判断），应该：
1. 标记任务为 `failed`
2. 说明需要人工决策的具体原因
3. 列出可选方案和各自的利弊
4. 让用户修改任务描述后重新执行

**示例**：同时开发用户、订单、支付、商品模块

---

#### 📋 工作流选择标准

| 特征 | 即时执行型 | 串行任务型 | DAG 任务型 ⭐ |
|------|-----------|----------|--------------|
| **任务数量** | 1 个 | 2-5 个 | ≥ 3 个 |
| **任务关系** | 单一操作 | 严格串行 | 串行/并行混合 |
| **并行可能** | 无 | 无 | ✅ 有 |
| **中断风险** | 低 | 中 | 高 |
| **断点续传** | 不需要 | 需要 | 强烈需要 |
| **文件冲突** | 无 | 无 | ✅ 需要检测 |
| **状态可视化** | 无 | 简单 | ✅ 完整 |

**快速决策流程**：

```
新任务开始
    ↓
任务是单一操作？
    ↓ 是 → 【即时执行型】
    ↓ 否
任务 < 3 且严格串行？
    ↓ 是 → 【串行任务型】（/todo-write）
    ↓ 否
任务 ≥ 3 或有并行可能？
    ↓ 是 → 【DAG 任务型】（/todo-huge-task）⭐
```

**具体场景选择**：

| 场景 | 推荐工作流 | 理由 |
|------|----------|------|
| 单一操作 | 即时执行型 | 简单快速 |
| 2-5个串行任务 | 串行任务型 | 支持断点续传 |
| ≥3个任务且可并行 | **DAG 任务型** | 并行提速 + 断点续传 |
| 大型重构 | **DAG 任务型** | 复杂编排 + 状态管理 |
| 多模块开发 | **DAG 任务型** | 并行开发 + 冲突检测 |
| 项目健康检查 | **DAG 任务型** | 并行检查 + 自动生成修复任务 |

---

#### 🎯 设计理念

**核心原则**：不是"强制统一"，而是"根据复杂度选择合适工具"

- ✅ **简单任务保持简单**（即时执行型）
- ✅ **线性任务有序执行**（串行任务型）
- ✅ **复杂任务智能编排**（DAG 任务型）
- ✅ **明确选择标准**（避免困惑）
- ✅ **统一的任务格式**（DAG 格式）
- ✅ **复用强大基础设施**（batchcc.py）

**务实策略**：
- 不过度设计（简单任务不用 DAG）
- 不强制统一（保持灵活性）
- 明确边界（清晰的选择标准）
- 持续优化（根据实际使用情况调整）

## 优化方法论

当需要优化某个命令时，遵循以下步骤：

1. **目标识别** - 从模糊需求中提取核心意图
   - 这个命令真正要解决什么问题？
   - 核心价值是什么？

2. **职责分离** - 确保单一职责
   - 是否做了太多事？
   - 是否与其他命令重复？

3. **约束平衡** - 在灵活性与规范性之间平衡
   - 哪些约束是必须的？
   - 哪些细节应该让 AI 自主决定？

4. **结构优化** - 使用清晰的层次结构
   - 信息是否有清晰的逻辑层次？
   - 重点是否突出？

5. **精简表达** - 删除冗余，保留核心
   - 能用一句话说明的不用一段话
   - 能引用模板的不内嵌示例

---

**维护日期**: 2025-11-10
**命令总数**: 20个核心命令 + 完善的模板体系

---

## 📚 新增功能：DAG 任务编排系统

### 核心文档
- **命令文件**: `todo-huge-task.md` - 大任务智能拆分与编排
- **格式规范**: `templates/workflow/DAG_TASK_FORMAT.md` - 完整的 STAGE/TASK 语法
- **空白模板**: `templates/workflow/DAG_TASK_TEMPLATE.md` - 快速开始模板
- **示例文件**:
  - `templates/workflow/DAG_EXAMPLE_ECOMMERCE.md` - 电商系统开发示例
  - `templates/workflow/DAG_EXAMPLE_MIGRATION.md` - 数据迁移项目示例

### 使用方式
```bash
# 1. 生成任务编排文件
/todo-huge-task "实现电商用户和订单系统"

# 2. 预览执行计划
python batchcc.py todo-task --dry-run

# 3. 执行任务（自动处理串行/并行/依赖）
python batchcc.py todo-task
```

### 关键特性
- ✅ **智能编排** - STAGE 控制串行/并行，TASK 定义具体任务
- ✅ **冲突检测** - 自动分析文件范围，避免并发修改冲突
- ✅ **依赖管理** - 支持阶段依赖和任务依赖
- ✅ **失败策略** - stop/continue/retry 灵活控制
- ✅ **可视化** - 清晰的执行计划预览
