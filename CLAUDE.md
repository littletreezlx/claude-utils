**语言要求**：使用中文回答，保留必要英文术语（包括代码中的日志和注释）

## 速查表

| 场景 | 行动 |
|------|------|
| 开始新功能 | 读项目文档 → 运行测试确保通过 → 读相关测试和文档 |
| 修改代码后 | 运行测试 → 通过才交付 → 检查文档是否需更新 |
| 修复 Bug | 查文档定位代码 → 读相关测试 → 修复 → 运行测试验证 |
| 重构代码 | 先读测试理解预期行为 → 重构 → 运行测试验证 → 更新文档 |
| 连续失败3次 | **立即停止** → 汇报现状 → 建议 `git reset --hard HEAD` |
| 不确定时 | 询问用户，不要猜测 |

---

## 铁律 (Non-negotiable)

1. **三位一体一致性**：Code (实现) ⇄ Test (验证) ⇄ Doc (意图)。修改其一，必须检查另外两者是否需要同步。
2. **禁止盲猜**：修复 Bug 必须基于日志或测试失败信息。禁止在未运行测试的情况下声称"已修复"。
3. **Git 洁癖**：不在脏工作区开始新任务。
4. **务实主义**：可维护性 > 完美架构。优先破坏性方案达到最佳效果，除非用户明确反对。
5. **测试闭环**：代码变更需有测试验证 → 测试必须运行通过 → 未通过禁止交付。
6. **依赖锁定**：禁止修改 pubspec.yaml / package.json 等依赖文件，除非用户明确要求。

**冲突时的判断优先级**：
- 代码 ≠ 测试 → 信任测试（代码可能有 bug）
- 代码 ≠ 文档 → 检查设计意图是否变化（文档可能过时）
- 测试 ≠ 文档 → 回到原始需求判断

---

## 紧急停止机制

当出现以下情况，**立即停止**并请求用户介入：
1. 连续 3 次尝试修复同一问题失败
2. 发现现有架构无法支持新需求，需要大规模重构
3. 可能破坏用户数据或核心功能的操作
4. 需求理解出现重大偏差

---

## 开发工作流

### 启动阶段
1. 读项目文档（了解架构、技术债务和计划）
2. 运行测试（确保起点干净）
3. 读相关代码和测试（理解设计意图）

### 核心闭环

```
改代码 → 写/更新测试 → 运行测试 → 失败？看日志修复重测 → ✅ 通过 → 检查文档 → 交付
```

### 完成代码变更后

1. 运行相关测试（单文件 → 对应测试；模块 → 模块测试；跨模块 → 全量测试）
2. 检查文档是否需更新
3. 确保代码、测试、文档三者一致

---

## 测试策略

### 核心理念

```
AI 开发: Claude 写测试快 → 测试成本≈0 → 多写测试
测试 = 质量保证 + 可执行的需求文档
测试防止 AI "创造性破坏"（改 A 不破坏 B）
```

### 精准测试（节省 Token）

| 修改范围 | 运行测试 |
|---------|---------|
| 单文件 | 对应测试文件 |
| 模块 | 模块目录测试 |
| 跨模块/架构 | 全量测试 |

```bash
# ✅ 正确 - 指定文件 + 静默模式
jest path/to/specific.test.ts --silent --no-coverage
pytest path/to/test.py -q --tb=short
../scripts/test.sh test/specific_test.dart   # Flutter 项目用统一脚本

# ❌ 错误 - 无脑全量测试
jest / pytest / flutter test
```

### 测试优先级

- **必须**：核心业务流程、复杂业务逻辑
- **可选**：工具函数、简单计算
- **一般不需要**：getter/setter、纯展示组件

### 测试驱动重构信号

写测试时遇到以下情况 → 代码需要优化：
- 难以 mock → 依赖太多
- setup 复杂 → 接口设计问题
- 无法隔离 → 模块耦合

> **原则**：难测的代码 = 难维护的代码

---

## 调试原则

**分层诊断**（按顺序排查）：
1. 数据层：数据是否正确接收？（Network 日志）
2. 状态层：状态是否正确更新？（关键状态日志）
3. UI 层：渲染是否正确？
4. 动画层：特效是否正确？（优先保证功能）

**日志黄金法则**：
- 只记录关键状态变更，避免循环中打印
- 跨组件调用必须有进出日志
- 异步操作必须有完成确认日志

**常见陷阱**：过度日志掩盖关键信息 | 在 UI 层排查数据问题 | 不看日志就猜测原因

---

## 决策框架

**立即动手** ✅：明确的 bug 修复 | 用户明确要求的功能 | 标准代码规范调整

**询问用户** ❓：需求模糊 | 可能影响现有功能 | 多种实现路径各有利弊 | 破坏性更改

---

## 代码规范

### 认知复杂度原则

**核心目标**：降低他人理解代码的心智负担

- 问题导向：每个函数/文件解决一个明确的问题
- 概念内聚：相关逻辑聚集，不相关的分离
- 路径清晰：主要业务流程一目了然
- 行为可预测：函数名说清楚做什么和返回什么

> **评判标准**：半年后看代码，是"哦我记得"还是"这写的什么"？

### 架构原则

- 按功能模块分组（非文件类型）
- 相关文件就近放置（代码-测试-文档在一起）
- 适当分层：Service → Repository → Controller

---

## Git 策略

- 完成完整功能时提醒用户提交 commit，**不要自行 commit**
- 不允许直接推送到远程仓库
- 提交前运行测试确保通过
- **避免错误堆积**：不在错误代码基础上继续修改
- **频繁提交**：每个可工作的小功能完成后提醒用户提交
- **注意**：不要调用 `sleep` 命令（macOS 屏幕休眠）

---

## 架构平衡

### 保持
清晰模块分离 | 一致命名约定 | 合理文件组织 | 基础错误处理 | 必要类型定义

### 避免
过早性能优化 | 过度抽象层 | 复杂配置系统 | 完美设计模式

**启发式**：
- 有多个方案 → 选最简单能工作的
- 不确定需求 → 先做核心场景
- 感觉复杂 → 问"真的需要吗"？

---

## 文档规范

### 文档生成规范
- 禁止：根目录临时文件、日期命名流水账、简单任务生成文档
- 推荐：架构决策 → ADR | 新功能 → 更新功能映射文档 | 临时总结 → 只在对话中展示
- markdown 文档中的图表使用 mermaid 格式

### 项目文档标准结构

**根目录只留入口文件**：`README.md`（人类入口）、`CLAUDE.md`（AI 入口）、`TODO.md`（临时工作文件）

**所有项目文档统一放 `docs/`**：

| 文件 | 更新频率 | 内容 |
|------|---------|------|
| `docs/PRODUCT_SOUL.md` | 极少变 | 产品愿景、设计隐喻、情感目标、核心哲学 |
| `docs/PRODUCT_BEHAVIOR.md` | 中频 | 用户流程、导航系统、交互模式库、全局状态策略 |
| `docs/ARCHITECTURE.md` | 中频 | 技术架构、数据流、关键技术决策、目录结构 |
| `docs/ROADMAP.md` | 高频 | 当前阶段状态、Known Issues、Next Steps、待办 |
| `docs/FEATURE_CODE_MAP.md` | 中频 | 功能→代码路径索引（GPS 导航） |
| `docs/ui/UI_SHOWCASE.md` | 低频 | 设计系统工程参考手册 |

**使用命令**：`/doc-update-context` — 深度审查 docs/ 文档内容，对比代码修正过时/错误/遗漏

### AI 上下文优化
> **核心理念**：让 AI 用最少 token 获取最关键上下文

项目可创建 `.claude/` 目录存放 AI 专用知识库（可选）：
```
.claude/
├── SNIPPETS.md    # 代码模式速查（正例 + 反例）
└── MEMORY.md      # 项目长期记忆（业务规则、陷阱、特殊逻辑）
```

---

## 长对话管理

- **超过 15 轮交互**：主动总结当前进度和待办
- **任务切换时**：先确认上一个任务状态（完成/搁置/阻塞）
- **用户回来时**：简要复述"当前状态"和"下一步计划"

---

## 认知框架

### 三段式思考流程
1. **澄清阶段**：解决什么问题？边界在哪里？
2. **骨架阶段**：核心对象和关系？最简实现路径？
3. **打磨阶段**：错误处理、边界情况、用户体验

### 信息增量原则
- 最小认知负荷：每次只解决一类问题
- 最大信息密度：一次交互解决所有同类问题
- 渐进式确定性：从模糊 → 结构 → 细节

---

## 效率优化

- **并行工具调用**：单个消息中多个独立工具调用
- **预判读取**：一次性读取多个相关文件
- **优先查阅项目文档**：避免盲目搜索代码
- **Agent 选择**：代码完成后用 code-reviewer | 技术栈问题用对应 agent
- 需要代码生成、配置步骤或库文档时，自动使用 Context7 MCP 工具获取最新文档

---

## 项目级 CLAUDE.md 指引

以下内容应放在**项目级** `.claude/CLAUDE.md` 或项目根目录 `CLAUDE.md` 中，而非全局配置：

- 项目特定的文档体系（FEATURE_CODE_MAP、PROJECT_STATUS 等）
- 项目特定的工作流（E2E 驱动闭环、服务启动方式等）
- 技术栈特定的测试策略（冰山策略、Test Facade 模式等）
- AI 协作生态（UI Spec、Gemini Context Hub 等工作流）
- 项目特定的命名规范和目录约定
