**语言要求**：使用中文回答，保留必要英文术语（包括代码中的日志和注释）

## 🚀 速查表

| 场景 | 行动 |
|------|------|
| 开始新功能 | 读 PROJECT_STATUS.md → 运行测试确保通过 → 读相关测试和文档 |
| 修改代码后 | 运行测试 → 通过才交付 → 检查文档是否需更新 |
| 修复 Bug | FEATURE_CODE_MAP.md → 定位代码 → 读相关测试 → 修复 → 验证 |
| 重构代码 | 先读测试理解预期行为 → 读 ADR 理解设计意图 → 重构 → 验证 |
| 连续失败3次 | **立即停止** → 汇报现状 → 建议 `git reset --hard HEAD` |
| 不确定时 | 询问用户，不要猜测 |

---

## 🛑 铁律 (Non-negotiable)

1. **三位一体一致性**：Code (实现) ⇄ Test (验证) ⇄ Doc (意图)。修改其一，必须检查另外两者。
2. **禁止盲猜**：修复 Bug 必须基于日志或测试失败信息。禁止在未运行测试的情况下声称"已修复"。
3. **Git 洁癖**：不在脏工作区开始新任务。
4. **务实主义**：可维护性 > 完美架构。优先破坏性方案达到最佳效果，除非用户明确反对。
5. **测试闭环**：改完代码必须写测试 → 写完测试必须运行 → 测试失败禁止交付。
6. **查阅优先**：修改前先查 FEATURE_CODE_MAP.md，严禁靠猜测定位代码。
7. **依赖锁定**：禁止修改 pubspec.yaml / package.json 等依赖文件，除非用户明确要求。

**冲突时的判断优先级**：
- 代码 ≠ 测试 → 信任测试（代码可能有 bug）
- 代码 ≠ 文档 → 检查设计意图是否变化（文档可能过时）
- 测试 ≠ 文档 → 回到原始需求判断

---

## 🚨 紧急停止机制

当出现以下情况，**立即停止**并请求用户介入：
1. 连续 3 次尝试修复同一问题失败
2. 发现现有架构无法支持新需求，需要大规模重构
3. 可能破坏用户数据或核心功能的操作
4. 需求理解出现重大偏差

---

## ✅ 开发工作流

### 启动阶段
1. 读 PROJECT_STATUS.md（了解技术债务和计划）
2. 运行测试（确保起点干净）
3. 读相关文档和测试（理解架构和设计意图）
4. 检查 FEATURE_CODE_MAP.md（避免重复实现）

### E2E 驱动闭环（核心）

```
改代码 → 写测试 → 启动服务 → 运行测试 → 看日志 → 失败？修复重测 → ✅ 通过交付
```

**执行要点**：
- 服务：后台启动 + 日志重定向（`./start.sh > logs/dev.log 2>&1 &`）
- 运行：headless 模式，不弹窗干扰用户
- 日志：测试前清空，优先 `grep -i "error\|exception"` 抓关键报错，无明显报错时 `tail -n 100`
- 检查：测试前确认服务已启动（`lsof -i :PORT`）

### 重构代码前（最易出问题）

1. 读 ADR 索引 - 理解设计意图
2. 读相关测试 - 理解预期行为
3. 运行测试 - 确保起点通过
4. 执行重构
5. 验证：测试通过 + 文档更新

### 完成代码变更后

1. 运行相关测试（单模块 → 模块测试；架构变更 → 全量测试）
2. 检查文档是否需更新（FEATURE_CODE_MAP、ADR、PROJECT_STATUS）
3. 确保代码、测试、文档三者一致

---

## 🧪 测试策略

### AI 开发测试理念

```
传统开发: 开发者理解代码 → 测试成本高 → 少写测试
AI 开发:  Claude 写测试快 → 测试成本≈0 → 多写测试
```

- 测试 = 质量保证 + 可执行的需求文档
- 测试防止 AI "创造性破坏"（改 A 不破坏 B）

### 精准测试（Token 效率）

| 修改范围 | 运行测试 |
|---------|---------|
| 单文件 | 对应测试文件 |
| 模块 | 模块目录测试 |
| 跨模块/架构 | 全量测试 |

```bash
# ✅ 正确 - 指定文件 + 静默模式（示例）
jest path/to/specific.test.ts --silent --no-coverage
pytest path/to/test.py -q --tb=short
flutter test test/specific_test.dart --reporter=compact

# ❌ 错误 - 无脑全量测试
jest / pytest / flutter test
```

### 测试优先级

- ✅ **必须**：核心业务流程、复杂业务逻辑
- ⏸️ **可选**：工具函数、简单计算
- ❌ **一般不需要**：getter/setter、纯展示组件

### 测试驱动重构信号

写测试时遇到以下情况 → 代码需要优化：
- 难以 mock → 依赖太多
- setup 复杂 → 接口设计问题
- 无法隔离 → 模块耦合

> **原则**：难测的代码 = 难维护的代码

---

## 🔍 调试原则

**分层诊断**（按顺序排查）：
1. 数据层：数据是否正确接收？（Network 日志）
2. 状态层：状态是否正确更新？（关键状态日志）
3. UI 层：渲染是否正确？
4. 动画层：特效是否正确？（优先保证功能）

**日志黄金法则**：
- 只记录关键状态变更，避免循环中打印
- 跨组件调用必须有进出日志
- 异步操作必须有完成确认日志

**常见陷阱**：过度日志掩盖关键信息 | 在 UI 层排查数据问题 | 不看日志就猜测原因

---

## 🎯 决策框架

**立即动手** ✅：明确的 bug 修复 | 用户明确要求的功能 | 标准代码规范调整

**询问用户** ❓：需求模糊 | 可能影响现有功能 | 多种实现路径各有利弊 | 破坏性更改

---

## 📋 代码规范

### 认知复杂度原则

**核心目标**：降低他人理解代码的心智负担

- 问题导向：每个函数/文件解决一个明确的问题
- 概念内聚：相关逻辑聚集，不相关的分离
- 路径清晰：主要业务流程一目了然
- 行为可预测：函数名说清楚做什么和返回什么
- **文件头部注释**：说明模块用途和关键设计决策

> **评判标准**：半年后看代码，是"哦我记得"还是"这写的什么"？

### 架构原则

- 按功能模块分组（非文件类型）
- 相关文件就近放置（代码-测试-文档在一起）
- 适当分层：Service → Repository → Controller

### 提交规范

- 完成完整功能时提醒用户提交 commit，**不要自行 commit**
- 提交前运行测试确保通过
- **注意**：不要调用 `sleep` 命令（macOS 屏幕休眠）

---

## 🚀 Git 策略
- 不允许直接推送到远程仓库
- **避免错误堆积**：不在错误代码基础上继续修改
- **频繁提交**：每个可工作的小功能完成后提交
- **失败即重置**：连续失败3次，暂停汇报，考虑 reset 换思路

---

## 🏗️ 架构平衡

### 保持 ✅
清晰模块分离 | 一致命名约定 | 合理文件组织 | 基础错误处理 | 必要类型定义

### 避免 ❌
过早性能优化 | 过度抽象层 | 复杂配置系统 | 完美设计模式

**启发式**：
- 有多个方案 → 选最简单能工作的
- 不确定需求 → 先做核心场景
- 感觉复杂 → 问"真的需要吗"？

---

## 📚 文档系统

### 核心文档（必须维护）
```
README.md            → 项目概述（人类阅读）
integration_test/    → 功能规范（唯一真相）
FEATURE_CODE_MAP.md  → 功能-代码映射（AI 导航）
CLAUDE.md            → AI 操作指南
```

**FEATURE_CODE_MAP 维护规则**：
- 新增功能/文件时，**必须**立即注册到此文件
- 重构导致文件移动/重命名时，**必须**同步更新
- **严禁**靠猜测定位代码，必须先查此地图

### 可选文档（按需维护）
- ABOUT.md - 项目初衷与愿景（为什么做这个项目）
- PROJECT_STATUS.md - 项目状态快照
- docs/decisions/ - ADR（重要架构决策）

### 文档生成规范
- ❌ 禁止：根目录临时文件、日期命名流水账、简单任务生成文档
- ✅ 推荐：架构决策 → ADR | 新功能 → 更新 FEATURE_CODE_MAP | 临时总结 → 只在对话中展示

---

## 🔄 长对话管理

- **超过 15 轮交互**：主动总结当前进度和待办
- **任务切换时**：先确认上一个任务状态（完成/搁置/阻塞）
- **用户回来时**：简要复述"当前状态"和"下一步计划"

---

## 🧠 认知框架

### 三段式思考流程
1. **澄清阶段**：解决什么问题？边界在哪里？
2. **骨架阶段**：核心对象和关系？最简实现路径？
3. **打磨阶段**：错误处理、边界情况、用户体验

### 信息增量原则
- 最小认知负荷：每次只解决一类问题
- 最大信息密度：一次交互解决所有同类问题
- 渐进式确定性：从模糊 → 结构 → 细节

---

## ⚡ 效率优化

- **并行工具调用**：单个消息中多个独立工具调用
- **预判读取**：一次性读取多个相关文件
- **优先查阅映射文档**：避免盲目搜索
- **Agent 选择**：代码完成后用 code-reviewer | 技术栈问题用对应 agent

---

## 🤖 AI 协作优化

### 上下文优化原则
> **核心理念**：让 AI 用最少 token 获取最关键上下文

项目可创建 `.claude/` 目录存放 AI 专用知识库（可选）：
```
.claude/
├── SNIPPETS.md    # 代码模式速查（正例 + 反例）
└── MEMORY.md      # 项目长期记忆（业务规则、陷阱、特殊逻辑）
```

### SNIPPETS.md 规范
代码模式文档应包含：
- ✅ **Do**：推荐的代码写法（附示例）
- ❌ **Don't**：禁止的代码写法（附示例和原因）
- 🎯 **Pattern**：常用代码模式模板

**负面约束比正面指令更能防止 Bug**。

### MEMORY.md 规范
记录 AI 需要"记住"的项目特定知识：
- 业务规则和边界条件
- 历史踩坑记录和解决方案
- 特殊依赖或环境要求
- 与其他系统的集成约定

### 已有文档优先
- `FEATURE_CODE_MAP.md` 已是功能路由表，无需重建
- `CLAUDE.md` 已包含铁律和工作流，保持精简
- 避免创建重复功能的新文档

---

## 🔧 工具

- 需要代码生成、配置步骤或库文档时，自动使用 Context7 MCP 工具获取最新文档。
- markdown文档中的图表都使用mermaid格式


---

## AI 协作生态 (AI Workflow Ecosystem)

本项目采用了 **"文档驱动开发 (Spec-Driven Development)"** 的 AI 协作模式。

## 角色指引

| Workflow/Command | 角色 | 职责 | 输入 | 输出 |
|----------|-----|------|------|------|
| **`/ui-spec`** | **Technical PM** | 逆向分析代码，提取逻辑 | 代码文件 / 截图 | `docs/ui/specs/xxx_spec.md` |
| **`/feat-discuss`** | **Tech Lead** | 澄清需求，同步文档 | 用户讨论 | 更新 `xxx_spec.md` |
| **`/ui-redesign`** | **Lead Designer** | 基于逻辑文档进行视觉重塑 | Spec 文档 + 截图 | 设计图 + `implementation_plan.md` |

### 最佳实践循环
1.  **理解现状**: 使用 `/ui-spec` 扫描现有代码，生成基础 Spec。
2.  **讨论需求**: 使用 `/feat-discuss` 讨论新想法，AI 会自动更新 Spec。
3.  **视觉落地**: 使用 `/ui-redesign` 读取最新的 Spec，生成既美观又符合逻辑的设计。

### 命名规范 (Naming Convention)
为了支持自动化分析，Spec 文档应与截图文件保持名称一致：
- 截图: `{base_name}.png` (例如: `ios_main_page.png`)
- Spec: `{base_name}_spec.md` (例如: `main_page_spec.md`)
- 映射关系维护在 `docs/ui/UI_SHOWCASE.md`。

---

## Gemini Context 工作流 (Product Partner Handoff)

### 核心理念：文档分层

**问题**: Gemini (产品合伙人) 不需要知道代码路径，但需要理解产品逻辑和用户体验。

**解决方案**: 维护两类文档

| 文档类型 | 目标读者 | 内容重点 | 示例 |
|---------|---------|---------|------|
| **技术实现文档** | Claude Code | 代码路径、行号、技术方案 | `docs/features/xxx.md` |
| **产品逻辑文档** | Gemini | 用户体验、设计哲学、产品权衡 | `${项目名}-context-for-gemini.md` |

### Gemini Context 原则 ⭐ Critical

**必须遵守的规则**:

1. **用产品语言，不写代码路径**
   - ✅ Good: "右滑标记已读，1:1 跟手，触觉反馈增强物理质感"
   - ❌ Bad: "使用 Dismissible Widget (article_list.dart:411)，触发 HapticFeedback.lightImpact()"

2. **聚焦用户体验和产品决策**
   - ✅ 描述功能对用户的价值（"地铁上仍可离线阅读"）
   - ❌ 描述技术实现细节（"使用 Drift 本地数据库"）

3. **必须包含"快速状态总览"**
   - 在文档开头列出完成度、核心能力、已知缺口
   - 避免 Gemini 误判项目进度（需要读完整文档才能了解现状）

4. **优先级明确，工时透明**
   - 下一步方向必须标注 P0/P1/P2/P3
   - 已知缺口必须包含预估工时（帮助 Gemini 决策）

### 相关 Commands

- **`/init-context-for-gemini`**: 生成/更新 Gemini context 文档
- **`/feat-discuss`**: 与 Gemini 讨论新功能，同步到 Spec 文档
- **`/feat-done`**: 功能完成后，生成 Gemini 验收报告

### 工作流示例

```
1. Claude 完成代码 → 更新技术文档 (docs/features/xxx.md)
2. Claude 同步更新 Gemini context (context-for-gemini.md)
3. Claude 生成验收报告 (/feat-done)
4. 用户将报告发给 Gemini → Gemini 基于 context 做产品决策
5. Gemini 给出下一步方向 → Claude 继续开发
```

**关键点**: Gemini 永远基于 `context-for-gemini.md` 做决策，而非技术实现文档。
