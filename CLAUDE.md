**语言要求**：使用中文回答，保留必要英文术语（包括代码中的日志和注释）

## ⭐ 核心行为准则

### 代码、测试、文档三位一体原则 🎯

代码、测试、文档相辅相成，互相验证，缺一不可：

```
代码 (What & How)  ←→  测试 (Verify)
  ↑                      ↑
  └──────  文档 (Why) ──┘
```

- **代码**：展示"如何实现"（实际的行为和逻辑）
- **测试**：验证"行为正确"（可执行的功能规范）
- **文档**：解释"设计意图"（为什么这么做、重要的架构决策）

> **核心原则**：三者必须保持一致。任何修改都要检查是否需要同步更新其他两者。

#### 三者不一致时的判断原则
当发现代码、测试、文档三者描述不一致时：
- **代码 ≠ 测试**：代码可能有 bug，优先信任测试
- **代码 ≠ 文档**：文档可能过时，但要检查是否是设计意图变化
- **测试 ≠ 文档**：可能都需要更新，回到原始需求判断

> **重要**：文档过时比没有文档更糟糕。发现过时文档立即更新或删除。

---

### 工作流中的强制检查点 ✅

#### 开发新功能前
1. **检查项目状态** - 读 PROJECT_STATUS.md（如果有），了解当前技术债务和计划
2. **运行测试** - 确保起点干净（所有测试通过）
3. **阅读文档** - 理解现有架构和设计意图（查阅 ADR 索引，如果有）
4. **检查功能映射** - 避免重复实现，了解相关代码位置

#### 开发过程中（E2E 驱动模式）

> **核心**：Claude Code 必须形成"改代码→测试→验证→修复"的完整闭环，不依赖用户介入

**完整闭环**：
```
Claude 改代码 → 写测试 → 启动服务 → 运行测试 → 看日志
                                              ↓
                                    测试失败？立即修复
                                              ↓
                                         再次运行测试
                                              ↓
                                         ✅ 通过 → 交付
```

**执行步骤**：
1. **编写测试**：前端E2E + API集成 + 业务逻辑单元测试
2. **启动服务**：后台启动 + 日志重定向（`./start.sh > logs/dev.log 2>&1 &`）
3. **运行测试**：headless模式，不弹窗干扰用户
4. **查看日志**：前端console + 后端logs + API请求响应
5. **失败修复**：分析日志 → 修复 → 重测 → 通过才交付
6. **更新文档**：
   - 更新功能映射（新功能、代码位置变化）
   - 更新测试覆盖度地图（新增测试，如果维护这个文档）
   - 如有架构决策，添加 ADR
   - 如有技术债务，更新 PROJECT_STATUS.md

**禁止行为**：
- ❌ 改完代码不写测试
- ❌ 写完测试不运行
- ❌ 测试失败仍然交付
- ❌ 说"请用户自己测试"
- ❌ 不看日志就猜测问题
- ❌ 失败3次以上还继续修改（应该 git reset）

**核心技巧**：
1. **增量日志**：测试前清空日志文件，只读最后N行（`tail -n 50`）
2. **Headless模式**：默认不弹窗（Web: `playwright test`，Mobile: `flutter test integration_test/`）
3. **保留DEBUG**：调试阶段不过滤任何日志，优化方向是改进读取方式而非减少信息
4. **服务检查**：测试前确认服务已启动（`lsof -i :PORT`）

**技术栈示例**（项目CLAUDE.md详细说明具体命令）：
- Web: Playwright, Cypress
- Mobile: Flutter integration_test, Detox
- Backend: pytest, Jest

#### 重构代码前（最容易出问题的环节）
1. **读 ADR 索引**（如果有）- 理解设计意图和重要的架构决策（为什么这么设计）
2. **读测试策略**（如果有）- 理解测试即文档的理念（重构前必读）
3. **读相关测试** - 理解预期行为和关键场景（应该做什么）
4. **运行测试** - 确保起点通过
5. **执行重构** - 基于理解进行重构
6. **验证完成** - 测试通过 + 文档更新 = 真正完成

> **Claude Code 必须遵守**：重构前必须先阅读相关文档和测试，理解"为什么"和"做什么"

#### 完成任何代码变更后
1. 运行相关测试（单模块变更 → 该模块测试；架构变更 → 全量测试）
2. 检查文档是否需要更新：
   - **功能映射** - 代码位置变化？
   - **测试覆盖度地图** - 新增测试？（如果维护这个文档）
   - **ADR** - 重要架构决策？（如果维护这个文档）
   - **PROJECT_STATUS.md** - 技术债务或重大变更？（如果维护这个文档）
3. 确保代码、测试、文档三者一致

---

### 测试优先级（不追求覆盖率）

#### 必须测试 ✅
- 核心业务逻辑
- 用户主要功能流程
- 容易破坏的关键模块

#### 可选测试 ⏸️
- 边界情况和异常分支
- 性能测试
- 工具函数

#### 不需要测试 ❌
- 简单的 getter/setter
- 纯展示型组件
- 一次性脚本

**测试的真正价值**：
- 保证功能正常运行
- 通过编写测试倒推优化代码结构
- 识别过度设计（难以测试的代码往往设计有问题）
- 作为可执行的功能规范，防止重构破坏行为

---

### 执行决策框架 🎯

#### 决策模式选择

Claude Code 根据执行上下文采用不同的决策模式：

```
新任务开始
    ↓
是 DAG 任务？（通过 batchcc.py 执行）
    ↓ 是 → 【模式 2：完全自主】
    │        - 自主分析 → 自主决策 → 直接执行
    │        - 只在真正无法决策时标记失败
    ↓ 否
【模式 1：交互式】
    ↓
需求明确？
    ↓ 是 → 立即执行
    ↓ 否 → 询问用户
```

---

#### 模式 1：交互式开发（默认）

**使用场景**：
- 用户与 Claude 直接对话
- 适用命令：大部分即时执行型命令（`/code-review`, `/gitcommit`, `/feat-discuss` 等）

**立即动手** ✅
- 明确的 bug 修复
- 用户明确要求的功能实现
- 标准的代码规范调整
- 测试失败的修复

**询问用户** ❓
- 需求模糊或存在多种理解
- 可能影响现有功能的修改
- 有多种实现路径且各有利弊
- 涉及破坏性更改或数据迁移

**建议但不强制** 💡
- 代码重构和架构优化
- 性能提升建议
- 更好的实现方式推荐

---

#### 模式 2：DAG 自动化（无人值守）

**使用场景**：
- 通过 `batchcc.py` 执行的 DAG 任务编排
- 适用命令：`/todo-huge-task`, `/comprehensive-health-check`, `/refactor-project`, `/refactor-module` 等

**核心理念**：采用**完全自动化、无人值守**的执行模式

##### ✅ 应该做的
1. **自主分析**：深入理解任务目标和当前项目状态
2. **自主决策**：基于优先级、影响面、技术可行性选择最优方案
3. **直接执行**：不询问用户，直接实施选定的方案
4. **记录理由**：在日志中清晰说明决策依据和执行路径

##### ❌ 不应该做的
1. 询问"需要我帮您...吗？"
2. 列出多个选项让用户选择
3. 等待用户确认后才继续
4. 在任务执行过程中设计交互式环节

##### 示例对比

**❌ 错误做法**（打断自动化流程）：
```
分析完成，发现以下问题：
1. 配置文件缺失（高优先级）
2. 文档不完善（中优先级）
3. 代码冗余（低优先级）

需要我帮您：
1. 修复配置？
2. 更新文档？
3. 重构代码？

请告诉我从哪里开始！
```

**✅ 正确做法**（自主决策并执行）：
```
分析完成，发现以下问题：
1. 配置文件缺失（阻塞性）
2. 文档不完善（中等影响）
3. 代码冗余（低优先级）

决策：优先修复配置文件缺失，因为：
- 这是阻塞性问题，其他模块无法使用
- 修复成本低，影响面大
- 可以快速解决，立即产生价值

正在创建配置文件...
✅ 配置文件已创建

接下来更新文档，因为开发者需要知道如何使用...
```

##### 决策标准

**自动决策范围（无需询问）**：

技术层面：
- ✅ 修复明确的测试失败
- ✅ 更新过时的文档（有明确的新状态）
- ✅ 重构循环依赖（有明确的方向）
- ✅ 拆分职责混乱的大类（有明确的职责边界）
- ✅ 统一不一致的代码风格
- ✅ 补充缺失的类型注解

架构层面：
- ✅ 选择简单可行的方案（够用的简单方案 > 完美的复杂方案）
- ✅ 基于实际问题做决策（解决现存痛点，而非假想需求）
- ✅ 风险可控的重构（有测试覆盖、影响范围小）

**需要标记失败的情况**：

只在**真正无法决策**时才标记任务为 `failed`：

- ❌ 需要业务规则判断（如支付方式选择、数据迁移策略）
- ❌ 多种架构模式同等可行（如 MVC vs MVVM，无明确优劣）
- ❌ 涉及重大技术栈变更（如框架替换，需要团队决策）
- ❌ 破坏性更改影响用户（如 API 接口变更）

**失败时的处理**：
1. 标记任务状态为 `failed`
2. 在错误信息中清晰说明无法决策的具体原因
3. 列出可选方案和各自的优劣分析
4. 建议用户在任务描述或项目文档中补充必要信息

---

## 📋 开发规范

### 代码质量基线
- 文件职责分离，文件不超过 600 行
- 函数单一职责，函数不超过 60 行
- 代码嵌套层次不超过 4 层
- 单向依赖流动，避免循环依赖
- 语义化命名，函数内无空行保持紧凑
- 文件头部注释说明模块用途
- 合理、语义清晰的注释和日志

### 推荐架构模式（通用原则）

#### 组织原则
- **按功能模块分组，而非按文件类型** - 让 Claude Code 容易找到相关代码
- **相关文件就近放置** - 代码-测试-文档放在一起
- **适当的分层** - Service 层业务逻辑、Repository 层数据访问、Controller 层 API 路由
- **统一的错误处理和日志记录**

> **为什么对 AI 重要**：当 Claude Code 修改某个功能时，相关的代码、测试、文档都在附近，自然会全部看到，而不会遗漏。

#### 自文档化代码 📖

**关键文件顶部必须有注释块**，包含：

```typescript
/**
 * [模块名] - 简短描述
 *
 * 关键设计决策：
 * - [重要的业务规则或技术决策]
 * - [为什么这么设计]
 *
 * 常见用法：
 * - [主要的函数和用法示例]
 *
 * 相关文件：
 * - 测试: ./xxx.test.ts
 * - 文档: docs/xxx.md
 */
```

**示例**：
```typescript
/**
 * Payment Service - 支付核心业务逻辑
 *
 * 关键设计决策：
 * - 退款必须在24小时内（业务要求）
 * - 使用乐观锁防止并发问题
 * - 金额计算用 Decimal 避免精度问题
 *
 * 常见用法：
 * - processPayment(order)
 * - refundPayment(paymentId, reason)
 *
 * 测试：./payment.test.ts
 * 文档：docs/architecture/payment.md
 */
export class PaymentService { /* ... */ }
```

**价值**：Claude Code 读代码时立即理解设计意图，不需要去其他地方查找文档。

#### 有指导性的错误消息 💬

测试失败和错误提示应该是**可操作的指南**，包含：
- 发生了什么（清晰的错误描述）
- 为什么重要（相关的业务规则）
- 如何修复（具体的修复步骤）
- 相关位置（代码位置、文档链接）

```typescript
// ❌ 不好的错误
expect(refundHours).toBe(24)
// Expected: 24, Received: 72

// ✅ 有指导性的错误
expect(refundHours, `
退款时限验证失败

期望: 24小时内处理（业务要求）
实际: 72小时

为什么重要: 业务规定退款必须在24小时内完成
文档: docs/architecture/payment.md#refund-policy
相关代码: src/services/payment.service.ts:123
修复建议: 检查 REFUND_DEADLINE 常量设置
`).toBe(24)
```

**价值**：Claude Code 看到测试失败时，能立即知道如何修复，而不是盲目尝试。

### 提交规范
- 完成完整功能时主动提醒用户提交 commit，不要自行commit
- 提交前运行测试确保通过
- commit 信息准确反映变更内容和原因
- **注意**：不要调用 sleep 命令（会导致 macOS 屏幕休眠）

---

## 🎯 文档系统设计（生成文档时参考）

### 为什么需要优化文档系统？

**个人开发者的真实痛点**：
- 😵 **6个月后完全忘记项目** - 不记得项目是干什么的、怎么启动
- 😵 **找不到代码位置** - 想改个功能，不知道在哪个文件
- 😵 **不理解设计意图** - 看到奇怪的代码，不知道为什么要这么写
- 😵 **测试文件散落各处** - 不知道有哪些测试、覆盖了什么
- 😵 **常用命令忘记** - 每次都要翻文档找怎么启动、测试、部署

**AI 开发的特殊挑战**：
- 🤖 AI 没有记忆 - 每次都是"第一次"接手项目
- 🤖 Token 有成本 - 读太多文档会很慢、很贵
- 🤖 需要精确信息 - 模糊的描述会导致错误理解

**解决方案**：建立一个**高效、清晰、可执行**的文档系统

---

### Token 效率优先 ⚡

**核心原则**：让"未来的 AI"用最少的 Token 理解项目

**传统问题**：
```
AI 需要读 5-7 个文档才能开始工作
→ README + API_DOC + DEVELOPER_GUIDE + 各种 README + 测试文档
→ 大量重复信息、过时信息、不相关信息
→ Token 浪费、理解困难
```

**优化策略**：
1. **核心文档精简化** - CLAUDE.md 控制在 600 行以内
   - 只写"为什么"和"怎么做"
   - 超出部分拆分到专项规范

2. **专项规范按需查阅** - 只在需要时读
   - API 规范（添加/修改 API 时读）
   - 测试规范（编写测试时读）
   - 类型规范（遇到类型错误时读）

3. **避免信息重复** - 测试即文档
   - 不在 README 和测试中重复写相同的功能说明
   - 测试是可执行的规范，README 解释"为什么"

4. **场景驱动导航** - 用"我要做X"替代"有什么文档"
   - 明确告诉 AI：做这个任务应该读哪些文档
   - 避免 AI 盲目搜索或过度阅读

---

### 场景驱动导航 🗺️

**从"有什么"到"我要做什么"**：

❌ **传统组织方式**（以文档类型为中心）：
```
docs/
├── api/           # API 文档
├── testing/       # 测试文档
├── architecture/  # 架构文档
└── deployment/    # 部署文档

AI 不知道该读哪个，只能都读一遍
```

✅ **场景驱动方式**（以任务为中心）：
```markdown
## 🎯 我（Claude Code）要做什么？

| 场景 | 应该读什么 | 为什么 |
|------|-----------|--------|
| 🆕 添加新功能 | E2E测试规范 + API规范 | 理解如何写测试和API |
| 🐛 修复 Bug | 项目状态快照 → 相关测试 | 快速定位代码位置 |
| ♻️ 重构代码 | 测试策略 + ADR 索引 | 理解"为什么"，避免破坏设计 |
| 🔍 理解项目 | 项目状态快照 → 功能映射 | 5分钟恢复上下文 |
| ❓ 遇到错误 | 错误定位表 | 快速找到负责模块 |
```

**价值**：
- AI 不需要猜测应该读哪些文档
- 避免过度阅读不相关的文档
- 明确的任务 → 文档路径

---

### 文档分层系统 📚

**个人开发者实用版**（不是企业级）：

#### ⭐ 第一层：核心文档（经常使用）
- **CLAUDE.md** - AI 操作指南（项目级 200-300 行）
- **PROJECT_STATUS.md** - 项目状态快照
  - 项目是什么、当前状态、技术债务、下一步计划
  - **解决"6个月后完全忘记项目"的问题**
- **FEATURE_CODE_MAP.md** - 功能代码映射
  - 功能名 → 页面、API、服务、测试的位置
  - **解决"找不到代码位置"的问题**
- **README.md** - 项目概览、快速开始

#### 📋 第二层：开发规范（开发时查阅）
- **docs/standards/API_STANDARDS.md** - API 响应格式规范
- **docs/standards/E2E_STANDARDS.md** - E2E 测试编写规范
- **docs/standards/TYPE_STANDARDS.md** - 类型注解规范
- **docs/operations/DAILY_COMMANDS.md** - 常用命令手册

#### 🎯 第三层：架构与决策（理解"为什么"）
- **docs/decisions/INDEX.md** - ADR（架构决策记录）
  - 记录重要的设计决策和原因
  - **解决"不理解设计意图"的问题**
- **docs/testing/strategy.md** - 测试策略（为什么 E2E 即文档）
- **docs/architecture/README.md** - 系统架构概览

#### 📖 第四层：辅助文档（需要时深入）
- **docs/testing/COVERAGE_MAP.md** - 测试覆盖度地图
  - **解决"测试文件散落各处"的问题**
- **docs/architecture/ERROR_LOCATOR.md** - 错误定位表
- 具体模块详细文档、部署指南、故障排查等

**注意**：
- 不是所有项目都需要全部层级的文档
- 根据项目复杂度选择合适的文档
- 简单项目可能只需要第一层的 3 个核心文档

---

### 标准文档结构（推荐）

```
项目根目录/
├── README.md                        # 项目概览
├── CLAUDE.md                        # AI 操作指南（200-300行）
├── PROJECT_STATUS.md                # 项目状态快照（可选）
├── FEATURE_CODE_MAP.md              # 功能代码映射
│
└── docs/
    ├── INDEX.md                     # 场景驱动索引（可选）
    │
    ├── standards/                   # 开发规范（按需）
    │   ├── API_STANDARDS.md
    │   ├── E2E_STANDARDS.md
    │   └── TYPE_STANDARDS.md
    │
    ├── testing/                     # 测试文档（按需）
    │   ├── COVERAGE_MAP.md          # 覆盖度地图
    │   └── strategy.md              # 测试策略
    │
    ├── decisions/                   # 架构决策（推荐）
    │   └── INDEX.md                 # ADR 集中管理
    │
    └── architecture/                # 架构文档（按需）
        ├── README.md                # 架构概览
        └── ERROR_LOCATOR.md         # 错误定位表
```

---

### 文档引用方式

当需要引用其他详细文档时：

```markdown
❌ 不要：@mention 整个文件（会膨胀 context window）
✅ 应该：说明何时去读该文档
  "遇到 [特定错误] 或需要 [复杂用法]，查看 path/to/docs.md"
```

---

### 文档生成和归档规范 📝

#### 任务完成时的文档决策流程

**在生成任何总结文档之前，必须先判断：**

1. **是否需要生成文档？**
   - ✅ 需要：重要架构决策（→ ADR）、新功能实现（→ 功能映射）、重大重构（→ 项目状态）
   - ❌ 不需要：简单 bug 修复、小调整、日常开发

2. **如果需要，属于哪种类型？**
   - **架构决策** → `docs/decisions/INDEX.md` 添加新 ADR
   - **功能说明** → 更新 `FEATURE_CODE_MAP.md`
   - **技术债务** → 更新 `PROJECT_STATUS.md`
   - **新测试** → 更新 `docs/testing/COVERAGE_MAP.md`（如果维护）
   - **API 变更** → 更新 `docs/standards/API_STANDARDS.md`（如果维护）
   - **重大变更** → 更新 `PROJECT_STATUS.md` 的重大变更记录

3. **生成到正确位置，而不是项目根目录**

#### 禁止行为 ❌
- **禁止在项目根目录生成临时总结文件**（如 `summary.md`, `notes.md`）
- **禁止生成日期命名的流水账**（如 `refactor-2024-11-04.md`）
- **禁止为简单任务生成文档**（用户没有要求时）

#### 推荐行为 ✅
- **任务开始前询问** - 是否需要生成文档？生成到哪里？
- **重要任务主动建议** - 这次重构涉及架构变化，建议添加 ADR
- **直接更新现有文档** - 而不是创建新文件
- **在对话中总结** - 临时性内容只在对话中展示，不生成文件

#### 允许的例外情况 ⚠️
- **`TODO.md`** - 项目改进待办清单（有明确行动计划，完成后归档）
- **`docs/health-check/YYYY-MM-DD-xxx.md`** - 健康检查报告（问题解决后归档）

---

## 🧠 个人开发者认知框架

### 信息增量原则
- **最小认知负荷** - 每次只解决一类问题（边界 OR 实现 OR 优化）
- **最大信息密度** - 一次交互解决所有同类问题，避免碎片化沟通
- **渐进式确定性** - 从模糊→结构→细节，每步都要可验证

### 三段式思考流程
1. **澄清阶段** - 这个功能解决什么问题？边界在哪里（做什么/不做什么）？
2. **骨架阶段** - 核心对象和关系是什么？最简单的实现路径？
3. **打磨阶段** - 错误处理、边界情况、用户体验优化

### 决策启发式
- 有多个方案 → 选最简单能工作的
- 不确定性能 → 先实现再优化
- 不确定需求 → 先做核心场景
- 感觉复杂 → 问"真的需要吗"？
- 失败3次以上 → 立即 git reset，换思路

---

## 🚀 Claude Code 效率优化

### 批量操作策略
- **并行工具调用** - 单个消息中使用多个工具调用
- **预判读取** - 一次性读取多个相关文件
- **优先查阅功能映射文档** - 避免盲目搜索
- **场景驱动导航** - 用 INDEX.md 快速找到需要的文档

### Agent 选择时机
- 代码完成后主动使用 **code-reviewer**
- 技术栈专业问题使用对应 agent（typescript-pro, python-pro 等）
- 架构设计时使用 backend-architect, frontend-developer

### Git 优先策略（生命线）
- **干净起点** - 每个新功能前确保 `git status` 干净
- **果断重置** - AI 代码混乱时立即 `git reset --hard HEAD`
- **避免错误堆积** - 不在错误代码基础上继续修改
- **频繁提交** - 每个可工作的小功能完成后立即提交
- **失败即重置** - 失败3次立即重置，换思路重新实现

---

## 🏗️ 架构平衡原则

### 良好架构 vs 过度设计

#### 保持的良好实践 ✅
- **清晰的模块分离** - 便于 Claude Code 理解和扩展
- **一致的命名约定** - 提高代码可预测性
- **合理的文件组织** - 让功能定位更快速
- **基础的错误处理** - 避免程序崩溃
- **必要的类型定义** - TypeScript 严格模式

#### 避免的过度设计 ❌
- 过早的性能优化
- 过度的抽象层（不为"可能的复用"而提前抽象）
- 复杂的配置系统（硬编码 > 简单配置 > 复杂系统）
- 完美的设计模式（够用的简单模式 > 完美的复杂模式）

### 架构决策检查清单

**何时采用更好的架构** ✅
- [ ] 让 Claude Code 更容易理解和操作项目
- [ ] 减少重复代码，显著提高开发效率
- [ ] 解决现存的维护痛点
- [ ] 为已确定的功能扩展做必要准备

**何时保持简单** ⏸️
- [ ] 功能需求还不明确或可能变动
- [ ] 可能只使用一两次的边缘场景
- [ ] 为了"可能的未来需求"而设计

---

## 🏛️ 开发理念

### 独立开发者原则
- 避免过度设计，优先简洁实用的解决方案
- 专注解决实际问题，而非追求完美架构
- 选择成熟稳定技术栈
- 代码够用即可，适度抽象和封装
- **务实的质量标准**：可维护 > 完美，能扩展 > 通用

### 兼容性处理原则
面对兼容性问题时，优先考虑破坏性解决方案以达到最佳效果；当影响较大时，提供选项让开发者自主决策
