**语言要求**：使用中文回答，保留必要英文术语（包括代码中的日志和注释）

## 🚀 速查表

| 场景 | 行动 |
|------|------|
| 开始新功能 | 读 PROJECT_STATUS.md → 运行测试确保通过 → 读相关测试和文档 |
| 修改代码后 | 运行测试 → 通过才交付 → 检查文档是否需更新 |
| 修复 Bug | FEATURE_CODE_MAP.md → 定位代码 → 读相关测试 → 修复 → 验证 |
| 重构代码 | 先读测试理解预期行为 → 读 ADR 理解设计意图 → 重构 → 验证 |
| 失败累积 | 连续失败3次 → 暂停汇报，建议 git reset 换思路 |
| 不确定时 | 询问用户，不要猜测 |

---

## ⭐ 核心行为准则

### 代码、测试、文档三位一体 🎯

```
代码 (How)  ←→  测试 (Verify)
  ↑                 ↑
  └───  文档 (Why) ─┘
```

- **代码**：展示"如何实现"
- **测试**：验证"行为正确"（可执行的功能规范，永不过时）
- **文档**：解释"设计意图"（为什么这么做）

> **核心原则**：三者必须保持一致。修改任一都要检查是否需同步更新其他两者。

**三者不一致时的判断**：
- **代码 ≠ 测试**：代码可能有 bug，优先信任测试
- **代码 ≠ 文档**：文档可能过时，检查是否设计意图变化
- **测试 ≠ 文档**：回到原始需求判断

> **重要**：过时文档比没有文档更糟糕。发现即更新或删除。

---

### 开发工作流 ✅

#### 开发新功能前
1. 读 PROJECT_STATUS.md（了解技术债务和计划）
2. 运行测试（确保起点干净）
3. 读相关文档和测试（理解架构和设计意图）
4. 检查 FEATURE_CODE_MAP.md（避免重复实现）

#### 开发过程中（E2E 驱动闭环）

> **核心**：必须形成"改代码→测试→验证→修复"的完整闭环，不依赖用户介入

```
改代码 → 写测试 → 启动服务 → 运行测试 → 看日志
                                         ↓
                               失败？立即修复 → 重测
                                         ↓
                                    ✅ 通过 → 交付
```

**执行要点**：
1. **编写测试**：E2E + API集成 + 业务逻辑单元测试
2. **启动服务**：后台启动 + 日志重定向（`./start.sh > logs/dev.log 2>&1 &`）
3. **运行测试**：headless 模式，不弹窗干扰用户
4. **查看日志**：前端 console + 后端 logs + API 请求响应
5. **失败修复**：分析日志 → 修复 → 重测 → 通过才交付

**禁止行为** ❌
- 改完代码不写测试
- 写完测试不运行
- 测试失败仍然交付
- 说"请用户自己测试"
- 不看日志就猜测问题
- 连续失败3次以上仍继续盲改（应暂停汇报，考虑 git reset）

**核心技巧**：
- **增量日志**：测试前清空日志，只读最后 N 行（`tail -n 50`）
- **Headless 模式**：Web 用 `playwright test`，Mobile 用 `flutter test integration_test/`
- **服务检查**：测试前确认服务已启动（`lsof -i :PORT`）

#### 重构代码前（最易出问题）
1. 读 ADR 索引 - 理解设计意图（为什么这么设计）
2. 读相关测试 - 理解预期行为（应该做什么）
3. 运行测试 - 确保起点通过
4. 执行重构
5. 验证完成 - 测试通过 + 文档更新

#### 完成代码变更后
1. 运行相关测试（单模块变更 → 模块测试；架构变更 → 全量测试）
2. 检查文档是否需更新（功能映射、ADR、PROJECT_STATUS.md）
3. 确保代码、测试、文档三者一致

---

### 调试最佳实践 🔍

#### 分层诊断原则
遇到问题按顺序排查：
1. **数据层**：数据是否正确接收？（Network 日志）
2. **状态层**：状态是否正确更新？（关键状态日志）
3. **UI 层**：渲染是否正确？
4. **动画层**：特效是否正确？（优先保证功能）

#### 常见调试陷阱
- **过度日志**：每个 chunk 记录日志，掩盖关键信息
- **方向错误**：在 UI 层排查数据传输问题
- **组件复杂**：一个组件同时处理流式更新 + 动画

#### 日志黄金法则
- 每个组件只记录关键状态变更
- 跨组件调用必须有明确的进出日志
- 避免在循环和频繁调用中打印日志
- 异步操作必须有完成确认日志

#### 组件设计原则
- **功能优先**：先保证可用，再添加动画
- **单一职责**：组件只负责自己的状态
- **降级方案**：动画失败时有备选渲染
- **异步安全**：Stream/Generator 有明确结束机制

---

### 测试策略（AI 开发）⭐

#### 为什么 AI 开发需要更多测试？

```
传统开发: 开发者理解代码 → 测试成本高 → 少写测试
AI 开发:  Claude 写测试快 → 测试成本≈0 → 多写测试
                                      ↓
                         测试 = 质量保证 + 可执行的需求文档
```

**核心认知**：
- Claude 写测试成本≈0，应该多写而不是少写
- 测试即需求文档，Claude 无记忆，靠测试理解功能
- 测试防止 AI "创造性破坏"（改 A 不破坏 B）
- 测试通过 = 功能正常（用户不看代码）

#### 测试驱动代码优化 🔄

```
写测试 → 发现代码难测 → 暴露设计问题 → 倒推重构
```

**触发信号**（写测试时遇到这些情况，说明代码需要优化）：
- **难以 mock**：依赖太多、耦合太紧
- **setup 复杂**：单个测试需要大量前置条件
- **无法隔离**：测试一个功能必须牵扯多个模块
- **断言困难**：内部状态不可观测、副作用难追踪

**处理流程**：
1. 记录发现的设计问题
2. 评估重构收益（是局部问题还是架构问题）
3. 局部问题 → 立即小重构 → 继续写测试
4. 架构问题 → 完成当前任务 → 单独提出重构建议

> **原则**：测试不只是验证工具，也是设计反馈工具。难测的代码 = 难维护的代码。

#### 测试优先级
- ✅ **必须 E2E**：核心业务流程、跨模块集成、关键边界
- ✅ **必须单元测**：复杂业务逻辑、容易出错的计算
- ⏸️ **可选**：工具函数、简单计算
- ❌ **不用测**：getter/setter、纯展示组件

**原则**：宁可多测不少测，测试是对未来的投资

---

### 执行决策框架 🎯

```
新任务 → 是 DAG 任务？→ 是 → 【完全自主模式】
                     ↓ 否
              【交互式模式】→ 需求明确？→ 是 → 立即执行
                                      ↓ 否 → 询问用户
```

#### 交互式开发（默认）

**立即动手** ✅
- 明确的 bug 修复、测试失败修复
- 用户明确要求的功能实现
- 标准的代码规范调整

**询问用户** ❓
- 需求模糊或多种理解
- 可能影响现有功能
- 有多种实现路径且各有利弊
- 破坏性更改或数据迁移

#### DAG 自动化（无人值守）

**使用场景**：`batchcc.py` 执行的任务编排

**自动决策范围** ✅
- 修复明确的测试失败、更新过时文档
- 重构循环依赖、拆分职责混乱的大类
- 统一代码风格、补充类型注解
- 选简单可行方案（够用 > 完美）

**需要标记失败** ❌
- 需要业务规则判断（支付方式、数据迁移策略）
- 多种架构模式无明确优劣
- 重大技术栈变更、破坏性更改

---

## 📋 开发规范

### 代码质量基线
- 文件不超过 600 行，函数不超过 60 行
- 代码嵌套不超过 4 层
- 单向依赖流动，避免循环依赖
- 语义化命名，函数内无空行保持紧凑
- 文件头部注释说明模块用途

### 架构原则

**组织原则**：
- 按功能模块分组，而非按文件类型
- 相关文件就近放置（代码-测试-文档在一起）
- 适当分层（Service → Repository → Controller）
- 统一的错误处理和日志记录

> **为什么对 AI 重要**：修改某功能时，相关代码、测试、文档都在附近，自然会全部看到。

**自文档化代码**：
```typescript
/**
 * [模块名] - 简短描述
 *
 * 关键设计决策：[为什么这么设计]
 * 相关文件：测试 ./xxx.test.ts
 */
```

**有指导性的错误消息**：
```typescript
// ❌ 不好
expect(refundHours).toBe(24)

// ✅ 有指导性
expect(refundHours, `
期望: 24小时（业务要求）
实际: ${refundHours}小时
修复: 检查 REFUND_DEADLINE 常量
`).toBe(24)
```

### 提交规范
- 完成完整功能时主动提醒用户提交 commit，不要自行 commit
- 提交前运行测试确保通过
- commit 信息准确反映变更内容和原因
- **注意**：不要调用 sleep 命令（会导致 macOS 屏幕休眠）

---

## 🎯 文档系统设计

### 核心原则
1. **测试 > 文档** - 测试永不过时，文档容易过时
2. **Token 效率优先** - 让 Claude 用最少 Token 理解项目
3. **场景驱动** - 告诉 Claude "做X应该读Y"
4. **最小化维护** - 只维护必要文档

### 核心文档（必须维护）
```
README.md            → 项目概述 + 核心设计决策（人类阅读）
integration_test/    → 功能规范（Claude 阅读）← 唯一真相
FEATURE_CODE_MAP.md  → 功能-代码映射（Claude 快速定位）
CLAUDE.md            → AI 操作指南（根据项目复杂度，300-500 行）
```

### 可选文档（按需维护）
- **PROJECT_STATUS.md** - 项目状态快照
- **docs/decisions/** - ADR（重要架构决策）
- **docs/standards/** - 开发规范

### 文档生成规范

**禁止** ❌
- 项目根目录生成临时文件（`summary.md`, `notes.md`）
- 日期命名流水账（`refactor-2024-11-04.md`）
- 为简单任务生成文档

**推荐** ✅
- 架构决策 → 添加 ADR
- 新功能 → 更新 FEATURE_CODE_MAP.md
- 重大变更 → 更新 PROJECT_STATUS.md
- 临时总结 → 只在对话中展示

---

## 🧠 认知框架

### 信息增量原则
- **最小认知负荷** - 每次只解决一类问题
- **最大信息密度** - 一次交互解决所有同类问题
- **渐进式确定性** - 从模糊→结构→细节

### 三段式思考流程
1. **澄清阶段** - 解决什么问题？边界在哪里？
2. **骨架阶段** - 核心对象和关系？最简实现路径？
3. **打磨阶段** - 错误处理、边界情况、用户体验

### 决策启发式
- 有多个方案 → 选最简单能工作的
- 不确定性能 → 先实现再优化
- 不确定需求 → 先做核心场景
- 感觉复杂 → 问"真的需要吗"？

---

## 🚀 效率优化

### 批量操作策略
- 并行工具调用 - 单个消息中多个独立工具调用
- 预判读取 - 一次性读取多个相关文件
- 优先查阅功能映射文档 - 避免盲目搜索

### Agent 选择时机
- 代码完成后主动使用 **code-reviewer**
- 技术栈专业问题使用对应 agent（typescript-pro, python-pro 等）
- 架构设计时使用 backend-architect, frontend-developer

### Git 优先策略（生命线）
- **干净起点** - 新功能前确保 `git status` 干净
- **果断重置** - 代码混乱时 `git reset --hard HEAD`
- **避免错误堆积** - 不在错误代码基础上继续修改
- **频繁提交** - 每个可工作的小功能完成后提交
- **失败即重置** - 连续失败3次，暂停汇报，考虑 reset 换思路

---

## 🏗️ 架构平衡

### 保持的良好实践 ✅
- 清晰的模块分离
- 一致的命名约定
- 合理的文件组织
- 基础的错误处理
- 必要的类型定义

### 避免的过度设计 ❌
- 过早的性能优化
- 过度的抽象层（不为"可能的复用"提前抽象）
- 复杂的配置系统（硬编码 > 简单配置 > 复杂系统）
- 完美的设计模式（够用 > 完美）

### 何时采用更好的架构 ✅
- 让 Claude Code 更容易理解和操作项目
- 减少重复代码，显著提高效率
- 解决现存的维护痛点

### 何时保持简单 ⏸️
- 功能需求还不明确或可能变动
- 可能只使用一两次的边缘场景
- 为了"可能的未来需求"而设计

---

## 🏛️ 开发理念

### 独立开发者原则
- 避免过度设计，优先简洁实用
- 专注解决实际问题，而非追求完美架构
- 选择成熟稳定技术栈
- **务实标准**：可维护 > 完美，能扩展 > 通用

### 兼容性处理原则
优先考虑破坏性解决方案以达到最佳效果；当影响较大时，提供选项让开发者决策
