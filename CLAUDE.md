**语言要求**：使用中文回答，保留必要英文术语（包括代码中的日志和注释）

## 🚀 速查表

| 场景 | 行动 |
|------|------|
| 开始新功能 | 读 PROJECT_STATUS.md → 运行测试确保通过 → 读相关测试和文档 |
| 修改代码后 | 运行测试 → 通过才交付 → 检查文档是否需更新 |
| 修复 Bug | FEATURE_CODE_MAP.md → 定位代码 → 读相关测试 → 修复 → 验证 |
| 重构代码 | 先读测试理解预期行为 → 读 ADR 理解设计意图 → 重构 → 验证 |
| 连续失败3次 | 暂停汇报，建议 `git reset --hard HEAD` 换思路 |
| 不确定时 | 询问用户，不要猜测 |

---

## ⭐ 核心原则

### 代码、测试、文档三位一体

```
代码 (How)  ←→  测试 (Verify)
  ↑                 ↑
  └───  文档 (Why) ─┘
```

- **代码**：展示"如何实现"
- **测试**：验证"行为正确"（可执行的功能规范，永不过时）
- **文档**：解释"设计意图"（为什么这么做）

> 三者必须保持一致。修改任一都要检查是否需同步更新其他两者。

**冲突时的判断**：
- 代码 ≠ 测试 → 优先信任测试（代码可能有 bug）
- 代码 ≠ 文档 → 检查设计意图是否变化（文档可能过时）
- 测试 ≠ 文档 → 回到原始需求判断

### 独立开发者理念

- 避免过度设计，优先简洁实用
- 专注解决实际问题，而非追求完美架构
- **务实标准**：可维护 > 完美，能扩展 > 通用
- **兼容性处理**：优先破坏性方案达到最佳效果；影响大时提供选项让用户决策

---

## ✅ 开发工作流

### 开发新功能前

1. 读 PROJECT_STATUS.md（了解技术债务和计划）
2. 运行测试（确保起点干净）
3. 读相关文档和测试（理解架构和设计意图）
4. 检查 FEATURE_CODE_MAP.md（避免重复实现）

### E2E 驱动闭环（核心）

```
改代码 → 写测试 → 启动服务 → 运行测试 → 看日志 → 失败？修复重测 → ✅ 通过交付
```

**执行要点**：
1. 测试：E2E + API集成 + 业务逻辑单元测试
2. 服务：后台启动 + 日志重定向（`./start.sh > logs/dev.log 2>&1 &`）
3. 运行：headless 模式，不弹窗干扰用户
4. 日志：测试前清空，只读最后 N 行（`tail -n 50`）

**核心技巧**：
- 服务检查：测试前确认服务已启动（`lsof -i :PORT`）
- Headless：Web 用 `playwright test`，Mobile 用 `flutter test integration_test/`

### 重构代码前（最易出问题）

1. 读 ADR 索引 - 理解设计意图（为什么这么设计）
2. 读相关测试 - 理解预期行为（应该做什么）
3. 运行测试 - 确保起点通过
4. 执行重构
5. 验证完成 - 测试通过 + 文档更新

### 完成代码变更后

1. 运行相关测试（单模块 → 模块测试；架构变更 → 全量测试）
2. 检查文档是否需更新（FEATURE_CODE_MAP、ADR、PROJECT_STATUS）
3. 确保代码、测试、文档三者一致

### 禁止行为 ❌

- 改完代码不写测试 / 写完测试不运行 / 测试失败仍交付
- 说"请用户自己测试" / 不看日志就猜测问题
- 连续失败3次以上仍继续盲改

---

## 🧪 测试策略

### AI 开发测试理念

**核心认知**：
```
传统开发: 开发者理解代码 → 测试成本高 → 少写测试
AI 开发:  Claude 写测试快 → 测试成本≈0 → 多写测试
```

- 测试 = 质量保证 + 可执行的需求文档
- 测试防止 AI "创造性破坏"（改 A 不破坏 B）
- 测试通过 = 功能正常

### 精准测试（Token 效率）

| 修改范围 | 运行测试 |
|---------|---------|
| 单文件 | 对应测试文件 |
| 模块 | 模块目录测试 |
| 跨模块/架构 | 全量测试 |

```bash
# ✅ 正确 - 指定文件 + 静默模式
jest path/to/specific.test.ts --silent --no-coverage --forceExit
pytest path/to/test.py -q --tb=short
flutter test test/specific_test.dart --reporter=compact

# ❌ 错误 - 全量测试浪费 token
jest
```

### 测试优先级

- ✅ **必须**：核心业务流程、复杂业务逻辑
- ⏸️ **可选**：工具函数、简单计算
- ❌ **不用**：getter/setter、纯展示组件、Widget/组件测试

> Widget 测试：E2E 已间接覆盖，Mock 状态管理复杂，UI 变更频繁，ROI 低

### 测试驱动重构

**信号**（写测试时遇到 → 代码需要优化）：
- 难以 mock → 依赖太多
- setup 复杂 → 接口设计问题
- 无法隔离 → 模块耦合

> **原则**：难测的代码 = 难维护的代码

---

## 🔍 调试原则

**分层诊断**（按顺序排查）：
1. 数据层：数据是否正确接收？（Network 日志）
2. 状态层：状态是否正确更新？（关键状态日志）
3. UI 层：渲染是否正确？
4. 动画层：特效是否正确？（优先保证功能）

**日志黄金法则**：
- 只记录关键状态变更，避免循环中打印
- 跨组件调用必须有进出日志
- 异步操作必须有完成确认日志

**常见陷阱**：过度日志掩盖关键信息 | 在 UI 层排查数据问题 | 一个组件同时处理流式+动画

**组件设计原则**：
- 功能优先：先保证可用，再添加动画
- 单一职责：组件只负责自己的状态
- 降级方案：动画失败时有备选渲染
- 异步安全：Stream/Generator 有明确结束机制

---

## 🎯 决策框架

**立即动手** ✅：明确的 bug 修复 | 用户明确要求的功能 | 标准代码规范调整

**询问用户** ❓：需求模糊 | 可能影响现有功能 | 多种实现路径各有利弊 | 破坏性更改

---

## 📋 代码规范

### 认知复杂度原则

**核心目标**：降低他人理解代码的心智负担

**关键原则**：
- 问题导向：每个函数/文件都解决一个明确的问题
- 概念内聚：相关逻辑聚集在一起，不相关的不放一起
- 路径清晰：主要业务流程一目了然，不被细节干扰
- 行为可预测：函数名说清楚做什么，看完就知道返回什么
- **文件头部注释**：必须说明模块用途和关键设计决策

> **评判标准**：半年后你看到代码时，是"哦我记得这个"，还是"这是写的什么？"

### 架构原则
- 按功能模块分组（非文件类型）
- 相关文件就近放置（代码-测试-文档在一起）
- 适当分层：Service → Repository → Controller

### 自文档化代码

```typescript
/**
 * [模块名] - 简短描述
 *
 * 关键设计决策：[为什么这么设计]
 * 相关文件：测试 ./xxx.test.ts
 */
```

### 提交规范
- 完成完整功能时提醒用户提交 commit，**不要自行 commit**
- 提交前运行测试确保通过
- **注意**：不要调用 `sleep` 命令（macOS 屏幕休眠）

---

## 🚀 Git 策略（生命线）

- **干净起点**：新功能前确保 `git status` 干净
- **果断重置**：代码混乱时 `git reset --hard HEAD`
- **避免错误堆积**：不在错误代码基础上继续修改
- **频繁提交**：每个可工作的小功能完成后提交
- **失败即重置**：连续失败3次，暂停汇报，考虑 reset 换思路

---

## 🏗️ 架构平衡

### 保持 ✅
清晰模块分离 | 一致命名约定 | 合理文件组织 | 基础错误处理 | 必要类型定义

### 避免 ❌
过早性能优化 | 过度抽象层 | 复杂配置系统 | 完美设计模式

**启发式**：
- 有多个方案 → 选最简单能工作的
- 不确定需求 → 先做核心场景
- 感觉复杂 → 问"真的需要吗"？

---

## 📚 文档系统

### 核心文档（必须维护）
```
README.md            → 项目概述（人类阅读）
integration_test/    → 功能规范（唯一真相）
FEATURE_CODE_MAP.md  → 功能-代码映射
CLAUDE.md            → AI 操作指南
```

### 可选文档（按需维护）
- PROJECT_STATUS.md - 项目状态快照
- docs/decisions/ - ADR（重要架构决策）
- docs/standards/ - 开发规范

### 文档生成规范
- ❌ 禁止：根目录临时文件、日期命名流水账、简单任务生成文档
- ✅ 推荐：架构决策 → ADR | 新功能 → 更新 FEATURE_CODE_MAP | 临时总结 → 只在对话中展示

---

## 🧠 认知框架

### 三段式思考流程
1. **澄清阶段**：解决什么问题？边界在哪里？
2. **骨架阶段**：核心对象和关系？最简实现路径？
3. **打磨阶段**：错误处理、边界情况、用户体验

### 信息增量原则
- 最小认知负荷：每次只解决一类问题
- 最大信息密度：一次交互解决所有同类问题
- 渐进式确定性：从模糊 → 结构 → 细节

---

## ⚡ 效率优化

- **并行工具调用**：单个消息中多个独立工具调用
- **预判读取**：一次性读取多个相关文件
- **优先查阅映射文档**：避免盲目搜索
- **Agent 选择**：代码完成后用 code-reviewer | 技术栈问题用对应 agent

---

## 🔧 MCP 工具

需要代码生成、配置步骤或库文档时，自动使用 Context7 MCP 工具获取最新文档。
