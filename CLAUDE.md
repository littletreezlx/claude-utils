**语言要求**：使用中文回答，保留必要英文术语（包括代码中的日志和注释）

## ⭐ 核心行为准则

### 代码、测试、文档三位一体原则 🎯

代码、测试、文档相辅相成，互相验证，缺一不可：

```
代码 (What & How)  ←→  测试 (Verify)
  ↑                      ↑
  └──────  文档 (Why) ──┘
```

- **代码**：展示"如何实现"（实际的行为和逻辑）
- **测试**：验证"行为正确"（可执行的功能规范）
- **文档**：解释"设计意图"（为什么这么做、重要的架构决策）

> **核心原则**：三者必须保持一致。任何修改都要检查是否需要同步更新其他两者。

#### 三者不一致时的判断原则
当发现代码、测试、文档三者描述不一致时：
- **代码 ≠ 测试**：代码可能有 bug，优先信任测试
- **代码 ≠ 文档**：文档可能过时，但要检查是否是设计意图变化
- **测试 ≠ 文档**：可能都需要更新，回到原始需求判断

> **重要**：文档过时比没有文档更糟糕。发现过时文档立即更新或删除。

---

### 工作流中的强制检查点 ✅

#### 开发新功能前
1. **检查项目状态** - 读 PROJECT_STATUS.md（如果有），了解当前技术债务和计划
2. **运行测试** - 确保起点干净（所有测试通过）
3. **阅读文档** - 理解现有架构和设计意图（查阅 ADR 索引，如果有）
4. **检查功能映射** - 避免重复实现，了解相关代码位置

#### 开发过程中（E2E 驱动模式）

> **核心**：Claude Code 必须形成"改代码→测试→验证→修复"的完整闭环，不依赖用户介入

**完整闭环**：
```
Claude 改代码 → 写测试 → 启动服务 → 运行测试 → 看日志
                                              ↓
                                    测试失败？立即修复
                                              ↓
                                         再次运行测试
                                              ↓
                                         ✅ 通过 → 交付
```

**执行步骤**：
1. **编写测试**：前端E2E + API集成 + 业务逻辑单元测试
2. **启动服务**：后台启动 + 日志重定向（`./start.sh > logs/dev.log 2>&1 &`）
3. **运行测试**：headless模式，不弹窗干扰用户
4. **查看日志**：前端console + 后端logs + API请求响应
5. **失败修复**：分析日志 → 修复 → 重测 → 通过才交付
6. **更新文档**：
   - 更新功能映射（新功能、代码位置变化）
   - 更新测试覆盖度地图（新增测试，如果维护这个文档）
   - 如有架构决策，添加 ADR
   - 如有技术债务，更新 PROJECT_STATUS.md

**禁止行为**：
- ❌ 改完代码不写测试
- ❌ 写完测试不运行
- ❌ 测试失败仍然交付
- ❌ 说"请用户自己测试"
- ❌ 不看日志就猜测问题
- ❌ 失败3次以上还继续修改（应该 git reset）

**核心技巧**：
1. **增量日志**：测试前清空日志文件，只读最后N行（`tail -n 50`）
2. **Headless模式**：默认不弹窗（Web: `playwright test`，Mobile: `flutter test integration_test/`）
3. **保留DEBUG**：调试阶段不过滤任何日志，优化方向是改进读取方式而非减少信息
4. **服务检查**：测试前确认服务已启动（`lsof -i :PORT`）

**技术栈示例**（项目CLAUDE.md详细说明具体命令）：
- Web: Playwright, Cypress
- Mobile: Flutter integration_test, Detox
- Backend: pytest, Jest

#### 重构代码前（最容易出问题的环节）
1. **读 ADR 索引**（如果有）- 理解设计意图和重要的架构决策（为什么这么设计）
2. **读测试策略**（如果有）- 理解测试即文档的理念（重构前必读）
3. **读相关测试** - 理解预期行为和关键场景（应该做什么）
4. **运行测试** - 确保起点通过
5. **执行重构** - 基于理解进行重构
6. **验证完成** - 测试通过 + 文档更新 = 真正完成

> **Claude Code 必须遵守**：重构前必须先阅读相关文档和测试，理解"为什么"和"做什么"

#### 完成任何代码变更后
1. 运行相关测试（单模块变更 → 该模块测试；架构变更 → 全量测试）
2. 检查文档是否需要更新：
   - **功能映射** - 代码位置变化？
   - **测试覆盖度地图** - 新增测试？（如果维护这个文档）
   - **ADR** - 重要架构决策？（如果维护这个文档）
   - **PROJECT_STATUS.md** - 技术债务或重大变更？（如果维护这个文档）
3. 确保代码、测试、文档三者一致

---

### 测试策略（AI 主导开发）⭐

#### 为什么 AI 开发需要更多测试？

```
传统开发: 开发者理解代码 → 测试成本高 → 少写测试
AI 开发:  Claude 写测试快 → 测试成本≈0 → 多写测试
                                      ↓
                         测试 = 质量保证 + 可执行的需求文档
```

**核心认知转变**：
1. **Claude 写测试成本≈0** - 应该多写而不是少写
2. **测试即需求文档** - Claude 无记忆，靠测试理解功能
3. **防止 AI "创造性破坏"** - 改 A 功能时不破坏 B
4. **用户不看代码** - 测试通过 = 功能正常

#### 测试优先级（AI 开发）
- ✅ **必须 E2E**: 核心业务流程、跨模块集成、关键边界
- ✅ **必须单元测**: 复杂业务逻辑、容易出错的计算
- ⏸️ **可选测**: 工具函数、简单计算
- ❌ **不用测**: getter/setter、纯展示组件

**原则**: 宁可多测不少测，测试是对未来的投资

**测试的额外价值**:
- 通过测试倒推优化代码结构
- 识别过度设计（难测试的代码往往设计有问题）

---

### 执行决策框架 🎯

#### 决策模式

```
新任务 → 是 DAG 任务？→ 是 → 【完全自主模式】
                     ↓ 否
              【交互式模式】→ 需求明确？→ 是 → 立即执行
                                      ↓ 否 → 询问用户
```

#### 模式 1：交互式开发（默认）

**立即动手** ✅
- 明确的 bug 修复、测试失败修复
- 用户明确要求的功能实现
- 标准的代码规范调整

**询问用户** ❓
- 需求模糊或多种理解
- 可能影响现有功能
- 有多种实现路径且各有利弊
- 破坏性更改或数据迁移

---

#### 模式 2：DAG 自动化（无人值守）

**使用场景**: `batchcc.py` 执行的任务编排（`/todo-huge-task`, `/comprehensive-health-check` 等）

**核心**: 完全自动化，自主分析 → 自主决策 → 直接执行 → 记录理由

**自动决策范围**:
- ✅ 修复明确的测试失败、更新过时文档
- ✅ 重构循环依赖、拆分职责混乱的大类
- ✅ 统一代码风格、补充类型注解
- ✅ 选简单可行方案（够用 > 完美）
- ✅ 解决现存痛点（非假想需求）

**需要标记失败**:
- ❌ 需要业务规则判断（支付方式、数据迁移策略）
- ❌ 多种架构模式无明确优劣（MVC vs MVVM）
- ❌ 重大技术栈变更、破坏性更改

**示例对比**:
```
❌ 错误: "发现3个问题，需要我帮您：1.修复配置？2.更新文档？3.重构代码？"
✅ 正确: "发现配置缺失（阻塞性），优先修复因为...。正在创建配置文件..."
```

---

## 📋 开发规范

### 代码质量基线
- 文件职责分离，文件不超过 600 行
- 函数单一职责，函数不超过 60 行
- 代码嵌套层次不超过 4 层
- 单向依赖流动，避免循环依赖
- 语义化命名，函数内无空行保持紧凑
- 文件头部注释说明模块用途
- 合理、语义清晰的注释和日志

### 推荐架构模式（通用原则）

#### 组织原则
- **按功能模块分组，而非按文件类型** - 让 Claude Code 容易找到相关代码
- **相关文件就近放置** - 代码-测试-文档放在一起
- **适当的分层** - Service 层业务逻辑、Repository 层数据访问、Controller 层 API 路由
- **统一的错误处理和日志记录**

> **为什么对 AI 重要**：当 Claude Code 修改某个功能时，相关的代码、测试、文档都在附近，自然会全部看到，而不会遗漏。

#### 自文档化代码 📖

**关键文件顶部注释模板**:
```typescript
/**
 * [模块名] - 简短描述
 *
 * 关键设计决策：[为什么这么设计]
 * 常见用法：[主要函数]
 * 相关文件：测试 ./xxx.test.ts
 */
```

**示例**:
```typescript
/**
 * Payment Service - 支付核心业务逻辑
 *
 * 关键设计决策：
 * - 退款必须24小时内（业务要求）
 * - 金额用 Decimal 避免精度问题
 *
 * 测试：./payment.test.ts
 */
export class PaymentService { /* ... */ }
```

#### 有指导性的错误消息 💬

测试失败应包含：发生了什么 + 为什么重要 + 如何修复

```typescript
// ❌ 不好
expect(refundHours).toBe(24) // Expected: 24, Received: 72

// ✅ 有指导性
expect(refundHours, `
期望: 24小时（业务要求）
实际: 72小时
相关: src/services/payment.service.ts:123
修复: 检查 REFUND_DEADLINE 常量
`).toBe(24)
```

### 提交规范
- 完成完整功能时主动提醒用户提交 commit，不要自行commit
- 提交前运行测试确保通过
- commit 信息准确反映变更内容和原因
- **注意**：不要调用 sleep 命令（会导致 macOS 屏幕休眠）

---

## 🎯 文档系统设计（AI 主导开发）

### 为什么需要优化文档？

**个人开发痛点**: 6个月后完全忘记项目（功能、位置、设计意图）
**AI 开发挑战**: AI 无记忆、Token 有成本、需要精确信息

### 核心原则 ⚡

1. **测试 > 文档** - 测试永不过时，文档容易过时
2. **Token 效率优先** - 让 Claude 用最少 Token 理解项目
3. **场景驱动** - 告诉 Claude "做X应该读Y"，不是"有哪些文档"
4. **最小化维护** - 个人开发，只维护必要文档

### 核心文档（必须维护）✅

```
README.md            → 项目概述 + 核心设计决策（人类阅读）
integration_test/    → 功能规范（Claude 阅读）← 唯一真相，永不过时
FEATURE_CODE_MAP.md  → 功能-代码映射（Claude 快速定位）
CLAUDE.md            → AI 操作指南（项目级 200-300 行）
```

**为什么测试 > 文档？**
```
README 说功能 A → 代码改了 → README 忘更新 → 过时文档误导 Claude
测试说功能 A   → 代码改了 → 测试失败     → 强制更新测试
```

### 可选文档（按需维护）⏸️

- **PROJECT_STATUS.md** - 项目状态快照（6个月后快速恢复上下文）
- **docs/decisions/INDEX.md** - ADR（重要架构决策）
- **docs/standards/** - 开发规范（API、测试、类型等）

### 场景驱动导航示例 🗺️

项目级 CLAUDE.md 应该包含：

```markdown
## 🎯 Claude Code 场景指南

| 场景 | 应该读什么 |
|------|-----------|
| 🆕 添加新功能 | integration_test/ + FEATURE_CODE_MAP.md |
| 🐛 修复 Bug | FEATURE_CODE_MAP.md → 相关测试 |
| ♻️ 重构代码 | 先读测试理解预期行为 + ADR |
| 🔍 理解项目 | PROJECT_STATUS.md → FEATURE_CODE_MAP.md |
```

### 文档生成规范 📝

**禁止** ❌
- 项目根目录生成临时文件（`summary.md`, `notes.md`）
- 日期命名流水账（`refactor-2024-11-04.md`）
- 为简单任务生成文档

**推荐** ✅
- 架构决策 → 添加 ADR
- 新功能 → 更新 FEATURE_CODE_MAP.md
- 重大变更 → 更新 PROJECT_STATUS.md
- 临时总结 → 只在对话中展示

---

## 🧠 个人开发者认知框架

### 信息增量原则
- **最小认知负荷** - 每次只解决一类问题（边界 OR 实现 OR 优化）
- **最大信息密度** - 一次交互解决所有同类问题，避免碎片化沟通
- **渐进式确定性** - 从模糊→结构→细节，每步都要可验证

### 三段式思考流程
1. **澄清阶段** - 这个功能解决什么问题？边界在哪里（做什么/不做什么）？
2. **骨架阶段** - 核心对象和关系是什么？最简单的实现路径？
3. **打磨阶段** - 错误处理、边界情况、用户体验优化

### 决策启发式
- 有多个方案 → 选最简单能工作的
- 不确定性能 → 先实现再优化
- 不确定需求 → 先做核心场景
- 感觉复杂 → 问"真的需要吗"？
- 失败3次以上 → 立即 git reset，换思路

---

## 🚀 Claude Code 效率优化

### 批量操作策略
- **并行工具调用** - 单个消息中使用多个工具调用
- **预判读取** - 一次性读取多个相关文件
- **优先查阅功能映射文档** - 避免盲目搜索
- **场景驱动导航** - 用 INDEX.md 快速找到需要的文档

### Agent 选择时机
- 代码完成后主动使用 **code-reviewer**
- 技术栈专业问题使用对应 agent（typescript-pro, python-pro 等）
- 架构设计时使用 backend-architect, frontend-developer

### Git 优先策略（生命线）
- **干净起点** - 每个新功能前确保 `git status` 干净
- **果断重置** - AI 代码混乱时立即 `git reset --hard HEAD`
- **避免错误堆积** - 不在错误代码基础上继续修改
- **频繁提交** - 每个可工作的小功能完成后立即提交
- **失败即重置** - 失败3次立即重置，换思路重新实现

---

## 🏗️ 架构平衡原则

### 良好架构 vs 过度设计

#### 保持的良好实践 ✅
- **清晰的模块分离** - 便于 Claude Code 理解和扩展
- **一致的命名约定** - 提高代码可预测性
- **合理的文件组织** - 让功能定位更快速
- **基础的错误处理** - 避免程序崩溃
- **必要的类型定义** - TypeScript 严格模式

#### 避免的过度设计 ❌
- 过早的性能优化
- 过度的抽象层（不为"可能的复用"而提前抽象）
- 复杂的配置系统（硬编码 > 简单配置 > 复杂系统）
- 完美的设计模式（够用的简单模式 > 完美的复杂模式）

### 架构决策检查清单

**何时采用更好的架构** ✅
- [ ] 让 Claude Code 更容易理解和操作项目
- [ ] 减少重复代码，显著提高开发效率
- [ ] 解决现存的维护痛点
- [ ] 为已确定的功能扩展做必要准备

**何时保持简单** ⏸️
- [ ] 功能需求还不明确或可能变动
- [ ] 可能只使用一两次的边缘场景
- [ ] 为了"可能的未来需求"而设计

---

## 🏛️ 开发理念

### 独立开发者原则
- 避免过度设计，优先简洁实用的解决方案
- 专注解决实际问题，而非追求完美架构
- 选择成熟稳定技术栈
- 代码够用即可，适度抽象和封装
- **务实的质量标准**：可维护 > 完美，能扩展 > 通用

### 兼容性处理原则
面对兼容性问题时，优先考虑破坏性解决方案以达到最佳效果；当影响较大时，提供选项让开发者自主决策
